#include "dic.h"
#include "dicimage.h"
#include "cuda.h"
#include "cuda_runtime.h"
#include "cuda_runtime_api.h"
#include "device_launch_parameters.h"

// Define this to turn on error checking
#define CUDA_ERROR_CHECK

#define cudaCheckError() __cudaCheckError(__FILE__, __LINE__)

inline void __cudaCheckError(const char *file, const int line) {
#ifdef CUDA_ERROR_CHECK
    cudaError err = cudaGetLastError();
    if (cudaSuccess != err) {
        fprintf(stderr, "cudaCheckError() failed at %s:%i : %s\n",
                 file, line, cudaGetErrorString(err));
        exit(-1);
    }
    // More careful checking. However, this will affect performance.
    // Comment away if needed.
//    err = cudaDeviceSynchronize();
//    if(cudaSuccess != err) {
//        fprintf(stderr, "cudaCheckError() with sync failed at %s:%i : %s\n",
//                 file, line, cudaGetErrorString( err ));
//        exit(-1);
//    }
#endif
    return;
}

Dic::Dic() {}

Dic::~Dic() {
    cimgs.clear();
    free(df_dx_buffer);
    free(df_dy_buffer);
    df_dp_buffer.clear();

    g_buffer.clear();
    x_vec_buffer.clear();
    y_vec_buffer.clear();
    gradient_buffer.clear();
    hessian_gn_buffer.clear();
    QK_B_QKT_buffer.clear();

    for (std::size_t i = 0; i < cimgs.size(); i++) {
        plot_u[i].free();
        plot_v[i].free();
        plot_corrcoef[i].free();
    }
    plot_calcpoints.reset();
}

void Dic::performDicAnalysis() {
    std::ofstream of("./dic_analysis.txt");
    double start = clock();

    int height = rimg.gs.height;
    int width = rimg.gs.width;

    oHeight = static_cast<int>(ceil(static_cast<double>(rimg.gs.height) / static_cast<double>(params.subsetSpacing + 1)));
    oWidth = static_cast<int>(ceil(static_cast<double>(rimg.gs.width) / static_cast<double>(params.subsetSpacing + 1)));

    df_dx_buffer = (double*) malloc(height * width * sizeof(double));
    df_dx_buffer = (double*) malloc(height * width * sizeof(double));

    int radius = params.subsetSize;

    plot_calcpoints.alloc(oHeight, oWidth);
    g_buffer.resize((radius * 2 + 1) * (radius * 2 + 1), 0.0);
    df_dp_buffer.resize((radius * 2 + 1) * (radius * 2 + 1) * 6, 0.0);
    x_vec_buffer.resize(6, 0.0);
    y_vec_buffer.resize(6, 0.0);
    gradient_buffer.resize(6, 0.0);
    hessian_gn_buffer.resize(36, 0.0);
    QK_B_QKT_buffer.resize(36 * (rimg.bcoef.height - 5) * (rimg.bcoef.width - 5), 0.0);

    for (std::size_t i = 0; i < cimgs.size(); i++) {
        class_double_array plotu;
        class_double_array plotv;
        class_double_array plotcc;
        class_logical_array plotvp;

        plotu.alloc(oHeight, oWidth);
        plotv.alloc(oHeight, oWidth);
        plotcc.alloc(oHeight, oWidth);
        plotvp.alloc(oHeight, oWidth);

        plot_u.push_back(plotu);
        plot_v.push_back(plotv);
        plot_corrcoef.push_back(plotcc);
        plot_validpoints.push_back(plotvp);
    }

    bool result = preComputeRef();
    if(!result) {
        printf("Error in precompute");
        return;
    }
    /*// Dic for each current image
    for (std::size_t i = 0; i < cimgs.size(); i++) {
        preCompute(of, i);
        roi.set_cirroi(radius);
        analysis(of, i);
        plot_calcpoints.reset();
    }
    of.close();*/
}

__global__
void pcrKernel(double* df_dx_buffer, double* df_dy_buffer,
               int f_height, int f_width,
               double* bcoef, int b_height, int border_bcoef,
               int offset) {
    //bounds
    int li = border_bcoef - 2;
    int ri = border_bcoef + f_width - 1;
    int lj = border_bcoef - 2;
    int rj = border_bcoef + f_height - 1;

    int rows = (border_bcoef + f_width - 1) - (border_bcoef - 2) + 1;
    int cols = (border_bcoef + f_height - 1) - (border_bcoef - 2) + 1;

    //init with 0 based indexing, then add border_bcoef info
    int i = (offset + threadIdx.x) / cols;
    int j = (offset + threadIdx.x) % cols;

    //give proper final value
    i += li;
    j += lj;

    if(i > ri || j > rj) return;

    double b0 = bcoef[(j) + (i) * b_height];
    double b1 = bcoef[(j + 1) + (i) * b_height];
    double b2 = bcoef[(j + 2) + (i) * b_height];
    double b3 = bcoef[(j + 3) + (i) * b_height];
    double b4 = bcoef[(j + 4) + (i) * b_height];
    double b6 = bcoef[(j) + (i + 1) * b_height];
    double b7 = bcoef[(j + 1) + (i + 1) * b_height];
    double b8 = bcoef[(j + 2) + (i + 1) * b_height];
    double b9 = bcoef[(j + 3) + (i + 1) * b_height];
    double b10 = bcoef[(j + 5) + (i + 1) * b_height];
    double b12 = bcoef[(j) + (i + 2) * b_height];
    double b13 = bcoef[(j + 1) + (i + 2) * b_height];
    double b15 = bcoef[(j + 3) + (i + 2) * b_height];
    double b16 = bcoef[(j + 4) + (i + 2) * b_height];
    double b18 = bcoef[(j) + (i + 3) * b_height];
    double b19 = bcoef[(j + 1) + (i + 3) * b_height];
    double b20 = bcoef[(j + 2) + (i + 3) * b_height];
    double b21 = bcoef[(j + 3) + (i + 3) * b_height];
    double b22 = bcoef[(j + 4) + (i + 3) * b_height];
    double b24 = bcoef[(j) + (i + 4) * b_height];
    double b25 = bcoef[(j + 1) + (i + 4) * b_height];
    double b26 = bcoef[(j + 2) + (i + 4) * b_height];
    double b27 = bcoef[(j + 3) + (i + 4) * b_height];
    double b28 = bcoef[(j + 4) + (i + 4) * b_height];

    // Compute base index
    std::size_t lind_f = (j - (border_bcoef - 2)) + (i - (border_bcoef - 2)) * f_height;

    // Compute Gradients using b-spline coefficients
    // First order
    df_dx_buffer[lind_f] = 0.003472222222222222 * b18 - 0.009027777777777778 * b1 - 0.003472222222222222 * b10 - 0.0003472222222222222 * b0 + 0.09027777777777778 * b19 - 0.02291666666666667 * b2 + 0.2291666666666667 * b20 + 0.09027777777777778 * b21 + 0.003472222222222222 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 - 0.009027777777777778 * b3 - 0.0003472222222222222 * b4 - 0.003472222222222222 * b6 - 0.09027777777777778 * b7 - 0.2291666666666667 * b8 - 0.09027777777777778 * b9;
    df_dy_buffer[lind_f] = 0.009027777777777778 * b10 - 0.003472222222222222 * b1 - 0.0003472222222222222 * b0 - 0.02291666666666667 * b12 - 0.2291666666666667 * b13 + 0.2291666666666667 * b15 + 0.02291666666666667 * b16 - 0.009027777777777778 * b18 - 0.09027777777777778 * b19 + 0.09027777777777778 * b21 + 0.009027777777777778 * b22 - 0.0003472222222222222 * b24 - 0.003472222222222222 * b25 + 0.003472222222222222 * b27 + 0.0003472222222222222 * b28 + 0.003472222222222222 * b3 + 0.0003472222222222222 * b4 - 0.009027777777777778 * b6 - 0.09027777777777778 * b7 + 0.09027777777777778 * b9;
}

bool Dic::preComputeRef() {
    //copy reference image to device
    //stl is not directly supported in cuda
    printf("Precomputing reference image\n");
    double* device_df_dx_buffer;
    double* device_df_dy_buffer;

    int size = rimg.gs.height * rimg.gs.width;

    //allocate memory in device
    if(cudaSuccess != cudaMalloc(&device_df_dx_buffer, size * sizeof(double))) return false;
    if(cudaSuccess != cudaMalloc(&device_df_dy_buffer, size * sizeof(double))) return false;

    //see https://devtalk.nvidia.com/default/topic/465306/using-std-vector-in-cuda-kernel-its-posible-to-use-a-std-vector-inside-cuda-kernel-/
    //if(cudaSuccess != cudaMemcpy(device_df_dx_buffer, &df_dx_buffer[0], size * sizeof(double), cudaMemcpyHostToDevice)) return false;
    //if(cudaSuccess != cudaMemcpy(device_df_dy_buffer, &df_dy_buffer[0], size * sizeof(double), cudaMemcpyHostToDevice)) return false;
    double* device_rimg_bcoef_value;

    //top level class malloc
    int bcoefSize = (rimg.gs.height + 2 * rimg.border_bcoef) * (rimg.gs.width + 2 * rimg.border_bcoef);
    if(cudaSuccess != cudaMalloc(&device_rimg_bcoef_value, bcoefSize * sizeof(double))) return false;

    //memcpy class_img
    if(cudaSuccess != cudaMemcpy(device_rimg_bcoef_value, rimg.bcoef.value,
                                 bcoefSize * sizeof(double), cudaMemcpyHostToDevice)) return false;

    int threads = 512;
    int rows = (rimg.border_bcoef + rimg.gs.width - 1) - (rimg.border_bcoef - 2) + 1;
    int cols = (rimg.border_bcoef + rimg.gs.height - 1) - (rimg.border_bcoef - 2) + 1;
    int pSize = rows * cols;
    int iterations = pSize / threads + (pSize % threads != 0);

    for(int i = 0, offset = 0; i < iterations; i++, offset += threads) {
        pcrKernel<<<1, threads>>>(device_df_dx_buffer, device_df_dy_buffer,
                                  rimg.gs.height, rimg.gs.width,
                                  device_rimg_bcoef_value, rimg.bcoef.height, rimg.border_bcoef,
                                  offset);
    }
    cudaDeviceSynchronize();
    cudaCheckError();
    //get back results
    if(cudaSuccess != cudaMemcpy(df_dx_buffer, device_df_dx_buffer, size * sizeof(double), cudaMemcpyDeviceToHost)) return false;
    if(cudaSuccess != cudaMemcpy(df_dy_buffer, device_df_dy_buffer, size * sizeof(double), cudaMemcpyDeviceToHost)) return false;

    //free resources
    cudaFree(device_df_dx_buffer);
    cudaFree(device_df_dy_buffer);
    cudaFree(device_rimg_bcoef_value);
    return true;
}

void Dic::preCompute(std::ofstream &of, std::size_t currImg) {
    // Pre compute interpolation coefficients ---------------------------//
    int height = cimgs[currImg].bcoef.height;
    for (int i = 0; i < cimgs[currImg].bcoef.width - 5; i++) {
        for (int j = 0; j < height - 5; j++) {
            // Get bspline coefficients
            double b0 = cimgs[currImg].bcoef.value[(j) + (i) * height];
            double b1 = cimgs[currImg].bcoef.value[(j + 1) + (i) * height];
            double b2 = cimgs[currImg].bcoef.value[(j + 2) + (i) * height];
            double b3 = cimgs[currImg].bcoef.value[(j + 3) + (i) * height];
            double b4 = cimgs[currImg].bcoef.value[(j + 4) + (i) * height];
            double b5 = cimgs[currImg].bcoef.value[(j + 5) + (i) * height];
            double b6 = cimgs[currImg].bcoef.value[(j) + (i + 1) * height];
            double b7 = cimgs[currImg].bcoef.value[(j + 1) + (i + 1) * height];
            double b8 = cimgs[currImg].bcoef.value[(j + 2) + (i + 1) * height];
            double b9 = cimgs[currImg].bcoef.value[(j + 3) + (i + 1) * height];
            double b10 = cimgs[currImg].bcoef.value[(j + 4) + (i + 1) * height];
            double b11 = cimgs[currImg].bcoef.value[(j + 5) + (i + 1) * height];
            double b12 = cimgs[currImg].bcoef.value[(j) + (i + 2) * height];
            double b13 = cimgs[currImg].bcoef.value[(j + 1) + (i + 2) * height];
            double b14 = cimgs[currImg].bcoef.value[(j + 2) + (i + 2) * height];
            double b15 = cimgs[currImg].bcoef.value[(j + 3) + (i + 2) * height];
            double b16 = cimgs[currImg].bcoef.value[(j + 4) + (i + 2) * height];
            double b17 = cimgs[currImg].bcoef.value[(j + 5) + (i + 2) * height];
            double b18 = cimgs[currImg].bcoef.value[(j) + (i + 3) * height];
            double b19 = cimgs[currImg].bcoef.value[(j + 1) + (i + 3) * height];
            double b20 = cimgs[currImg].bcoef.value[(j + 2) + (i + 3) * height];
            double b21 = cimgs[currImg].bcoef.value[(j + 3) + (i + 3) * height];
            double b22 = cimgs[currImg].bcoef.value[(j + 4) + (i + 3) * height];
            double b23 = cimgs[currImg].bcoef.value[(j + 5) + (i + 3) * height];
            double b24 = cimgs[currImg].bcoef.value[(j) + (i + 4) * height];
            double b25 = cimgs[currImg].bcoef.value[(j + 1) + (i + 4) * height];
            double b26 = cimgs[currImg].bcoef.value[(j + 2) + (i + 4) * height];
            double b27 = cimgs[currImg].bcoef.value[(j + 3) + (i + 4) * height];
            double b28 = cimgs[currImg].bcoef.value[(j + 4) + (i + 4) * height];
            double b29 = cimgs[currImg].bcoef.value[(j + 5) + (i + 4) * height];
            double b30 = cimgs[currImg].bcoef.value[(j) + (i + 5) * height];
            double b31 = cimgs[currImg].bcoef.value[(j + 1) + (i + 5) * height];
            double b32 = cimgs[currImg].bcoef.value[(j + 2) + (i + 5) * height];
            double b33 = cimgs[currImg].bcoef.value[(j + 3) + (i + 5) * height];
            double b34 = cimgs[currImg].bcoef.value[(j + 4) + (i + 5) * height];
            double b35 = cimgs[currImg].bcoef.value[(j + 5) + (i + 5) * height];

            //Compute base index
            int lind_qkbqkt = j * (36) + i * (36 * (height - 5));

            //Compute QK_B_QKT vector
            QK_B_QKT_buffer[lind_qkbqkt] = 0.00006944444444444444 * b0 + 0.001805555555555556 * b1 + 0.001805555555555556 * b10 + 0.004583333333333333 * b12 + 0.1191666666666667 * b13 + 0.3025 * b14 + 0.1191666666666667 * b15 + 0.004583333333333333 * b16 + 0.001805555555555556 * b18 + 0.04694444444444444 * b19 + 0.004583333333333333 * b2 + 0.1191666666666667 * b20 + 0.04694444444444444 * b21 + 0.001805555555555556 * b22 + 0.00006944444444444444 * b24 + 0.001805555555555556 * b25 + 0.004583333333333333 * b26 + 0.001805555555555556 * b27 + 0.00006944444444444444 * b28 + 0.001805555555555556 * b3 + 0.00006944444444444444 * b4 + 0.001805555555555556 * b6 + 0.04694444444444444 * b7 + 0.1191666666666667 * b8 + 0.04694444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 1] = 0.009027777777777778 * b10 - 0.003472222222222222 * b1 - 0.0003472222222222222 * b0 - 0.02291666666666667 * b12 - 0.2291666666666667 * b13 + 0.2291666666666667 * b15 + 0.02291666666666667 * b16 - 0.009027777777777778 * b18 - 0.09027777777777778 * b19 + 0.09027777777777778 * b21 + 0.009027777777777778 * b22 - 0.0003472222222222222 * b24 - 0.003472222222222222 * b25 + 0.003472222222222222 * b27 + 0.0003472222222222222 * b28 + 0.003472222222222222 * b3 + 0.0003472222222222222 * b4 - 0.009027777777777778 * b6 - 0.09027777777777778 * b7 + 0.09027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 2] = 0.0006944444444444444 * b0 + 0.001388888888888889 * b1 + 0.01805555555555556 * b10 + 0.04583333333333333 * b12 + 0.09166666666666667 * b13 - 0.275 * b14 + 0.09166666666666667 * b15 + 0.04583333333333333 * b16 + 0.01805555555555556 * b18 + 0.03611111111111111 * b19 - 0.004166666666666667 * b2 - 0.1083333333333333 * b20 + 0.03611111111111111 * b21 + 0.01805555555555556 * b22 + 0.0006944444444444444 * b24 + 0.001388888888888889 * b25 - 0.004166666666666667 * b26 + 0.001388888888888889 * b27 + 0.0006944444444444444 * b28 + 0.001388888888888889 * b3 + 0.0006944444444444444 * b4 + 0.01805555555555556 * b6 + 0.03611111111111111 * b7 - 0.1083333333333333 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 3] = 0.001388888888888889 * b1 - 0.0006944444444444444 * b0 + 0.01805555555555556 * b10 - 0.04583333333333333 * b12 + 0.09166666666666667 * b13 - 0.09166666666666667 * b15 + 0.04583333333333333 * b16 - 0.01805555555555556 * b18 + 0.03611111111111111 * b19 - 0.03611111111111111 * b21 + 0.01805555555555556 * b22 - 0.0006944444444444444 * b24 + 0.001388888888888889 * b25 - 0.001388888888888889 * b27 + 0.0006944444444444444 * b28 - 0.001388888888888889 * b3 + 0.0006944444444444444 * b4 - 0.01805555555555556 * b6 + 0.03611111111111111 * b7 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 4] = 0.0003472222222222222 * b0 - 0.001388888888888889 * b1 + 0.009027777777777778 * b10 + 0.02291666666666667 * b12 - 0.09166666666666667 * b13 + 0.1375 * b14 - 0.09166666666666667 * b15 + 0.02291666666666667 * b16 + 0.009027777777777778 * b18 - 0.03611111111111111 * b19 + 0.002083333333333333 * b2 + 0.05416666666666667 * b20 - 0.03611111111111111 * b21 + 0.009027777777777778 * b22 + 0.0003472222222222222 * b24 - 0.001388888888888889 * b25 + 0.002083333333333333 * b26 - 0.001388888888888889 * b27 + 0.0003472222222222222 * b28 - 0.001388888888888889 * b3 + 0.0003472222222222222 * b4 + 0.009027777777777778 * b6 - 0.03611111111111111 * b7 + 0.05416666666666667 * b8 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 5] = 0.0003472222222222222 * b1 - 0.00006944444444444444 * b0 - 0.009027777777777778 * b10 + 0.001805555555555556 * b11 - 0.004583333333333333 * b12 + 0.02291666666666667 * b13 - 0.04583333333333333 * b14 + 0.04583333333333333 * b15 - 0.02291666666666667 * b16 + 0.004583333333333333 * b17 - 0.001805555555555556 * b18 + 0.009027777777777778 * b19 - 0.0006944444444444444 * b2 - 0.01805555555555556 * b20 + 0.01805555555555556 * b21 - 0.009027777777777778 * b22 + 0.001805555555555556 * b23 - 0.00006944444444444444 * b24 + 0.0003472222222222222 * b25 - 0.0006944444444444444 * b26 + 0.0006944444444444444 * b27 - 0.0003472222222222222 * b28 + 0.00006944444444444444 * b29 + 0.0006944444444444444 * b3 - 0.0003472222222222222 * b4 + 0.00006944444444444444 * b5 - 0.001805555555555556 * b6 + 0.009027777777777778 * b7 - 0.01805555555555556 * b8 + 0.01805555555555556 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 6] = 0.003472222222222222 * b18 - 0.009027777777777778 * b1 - 0.003472222222222222 * b10 - 0.0003472222222222222 * b0 + 0.09027777777777778 * b19 - 0.02291666666666667 * b2 + 0.2291666666666667 * b20 + 0.09027777777777778 * b21 + 0.003472222222222222 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 - 0.009027777777777778 * b3 - 0.0003472222222222222 * b4 - 0.003472222222222222 * b6 - 0.09027777777777778 * b7 - 0.2291666666666667 * b8 - 0.09027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 7] = 0.001736111111111111 * b0 + 0.01736111111111111 * b1 - 0.01736111111111111 * b10 - 0.01736111111111111 * b18 - 0.1736111111111111 * b19 + 0.1736111111111111 * b21 + 0.01736111111111111 * b22 - 0.001736111111111111 * b24 - 0.01736111111111111 * b25 + 0.01736111111111111 * b27 + 0.001736111111111111 * b28 - 0.01736111111111111 * b3 - 0.001736111111111111 * b4 + 0.01736111111111111 * b6 + 0.1736111111111111 * b7 - 0.1736111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 8] = 0.03472222222222222 * b18 - 0.006944444444444444 * b1 - 0.03472222222222222 * b10 - 0.003472222222222222 * b0 + 0.06944444444444444 * b19 + 0.02083333333333333 * b2 - 0.2083333333333333 * b20 + 0.06944444444444444 * b21 + 0.03472222222222222 * b22 + 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.02083333333333333 * b26 + 0.006944444444444444 * b27 + 0.003472222222222222 * b28 - 0.006944444444444444 * b3 - 0.003472222222222222 * b4 - 0.03472222222222222 * b6 - 0.06944444444444444 * b7 + 0.2083333333333333 * b8 - 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 9] = 0.003472222222222222 * b0 - 0.006944444444444444 * b1 - 0.03472222222222222 * b10 - 0.03472222222222222 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 + 0.03472222222222222 * b22 - 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.006944444444444444 * b27 + 0.003472222222222222 * b28 + 0.006944444444444444 * b3 - 0.003472222222222222 * b4 + 0.03472222222222222 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 10] = 0.006944444444444444 * b1 - 0.001736111111111111 * b0 - 0.01736111111111111 * b10 + 0.01736111111111111 * b18 - 0.06944444444444444 * b19 - 0.01041666666666667 * b2 + 0.1041666666666667 * b20 - 0.06944444444444444 * b21 + 0.01736111111111111 * b22 + 0.001736111111111111 * b24 - 0.006944444444444444 * b25 + 0.01041666666666667 * b26 - 0.006944444444444444 * b27 + 0.001736111111111111 * b28 + 0.006944444444444444 * b3 - 0.001736111111111111 * b4 - 0.01736111111111111 * b6 + 0.06944444444444444 * b7 - 0.1041666666666667 * b8 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 11] = 0.0003472222222222222 * b0 - 0.001736111111111111 * b1 + 0.01736111111111111 * b10 - 0.003472222222222222 * b11 - 0.003472222222222222 * b18 + 0.01736111111111111 * b19 + 0.003472222222222222 * b2 - 0.03472222222222222 * b20 + 0.03472222222222222 * b21 - 0.01736111111111111 * b22 + 0.003472222222222222 * b23 - 0.0003472222222222222 * b24 + 0.001736111111111111 * b25 - 0.003472222222222222 * b26 + 0.003472222222222222 * b27 - 0.001736111111111111 * b28 + 0.0003472222222222222 * b29 - 0.003472222222222222 * b3 + 0.001736111111111111 * b4 - 0.0003472222222222222 * b5 + 0.003472222222222222 * b6 - 0.01736111111111111 * b7 + 0.03472222222222222 * b8 - 0.03472222222222222 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 12] = 0.0006944444444444444 * b0 + 0.01805555555555556 * b1 + 0.001388888888888889 * b10 - 0.004166666666666667 * b12 - 0.1083333333333333 * b13 - 0.275 * b14 - 0.1083333333333333 * b15 - 0.004166666666666667 * b16 + 0.001388888888888889 * b18 + 0.03611111111111111 * b19 + 0.04583333333333333 * b2 + 0.09166666666666667 * b20 + 0.03611111111111111 * b21 + 0.001388888888888889 * b22 + 0.0006944444444444444 * b24 + 0.01805555555555556 * b25 + 0.04583333333333333 * b26 + 0.01805555555555556 * b27 + 0.0006944444444444444 * b28 + 0.01805555555555556 * b3 + 0.0006944444444444444 * b4 + 0.001388888888888889 * b6 + 0.03611111111111111 * b7 + 0.09166666666666667 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 13] = 0.006944444444444444 * b10 - 0.03472222222222222 * b1 - 0.003472222222222222 * b0 + 0.02083333333333333 * b12 + 0.2083333333333333 * b13 - 0.2083333333333333 * b15 - 0.02083333333333333 * b16 - 0.006944444444444444 * b18 - 0.06944444444444444 * b19 + 0.06944444444444444 * b21 + 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.03472222222222222 * b25 + 0.03472222222222222 * b27 + 0.003472222222222222 * b28 + 0.03472222222222222 * b3 + 0.003472222222222222 * b4 - 0.006944444444444444 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 14] = 0.006944444444444444 * b0 + 0.01388888888888889 * b1 + 0.01388888888888889 * b10 - 0.04166666666666667 * b12 - 0.08333333333333333 * b13 + 0.25 * b14 - 0.08333333333333333 * b15 - 0.04166666666666667 * b16 + 0.01388888888888889 * b18 + 0.02777777777777778 * b19 - 0.04166666666666667 * b2 - 0.08333333333333333 * b20 + 0.02777777777777778 * b21 + 0.01388888888888889 * b22 + 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.04166666666666667 * b26 + 0.01388888888888889 * b27 + 0.006944444444444444 * b28 + 0.01388888888888889 * b3 + 0.006944444444444444 * b4 + 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.08333333333333333 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 15] = 0.01388888888888889 * b1 - 0.006944444444444444 * b0 + 0.01388888888888889 * b10 + 0.04166666666666667 * b12 - 0.08333333333333333 * b13 + 0.08333333333333333 * b15 - 0.04166666666666667 * b16 - 0.01388888888888889 * b18 + 0.02777777777777778 * b19 - 0.02777777777777778 * b21 + 0.01388888888888889 * b22 - 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.01388888888888889 * b27 + 0.006944444444444444 * b28 - 0.01388888888888889 * b3 + 0.006944444444444444 * b4 - 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 16] = 0.003472222222222222 * b0 - 0.01388888888888889 * b1 + 0.006944444444444444 * b10 - 0.02083333333333333 * b12 + 0.08333333333333333 * b13 - 0.125 * b14 + 0.08333333333333333 * b15 - 0.02083333333333333 * b16 + 0.006944444444444444 * b18 - 0.02777777777777778 * b19 + 0.02083333333333333 * b2 + 0.04166666666666667 * b20 - 0.02777777777777778 * b21 + 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.01388888888888889 * b25 + 0.02083333333333333 * b26 - 0.01388888888888889 * b27 + 0.003472222222222222 * b28 - 0.01388888888888889 * b3 + 0.003472222222222222 * b4 + 0.006944444444444444 * b6 - 0.02777777777777778 * b7 + 0.04166666666666667 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 17] = 0.003472222222222222 * b1 - 0.0006944444444444444 * b0 - 0.006944444444444444 * b10 + 0.001388888888888889 * b11 + 0.004166666666666667 * b12 - 0.02083333333333333 * b13 + 0.04166666666666667 * b14 - 0.04166666666666667 * b15 + 0.02083333333333333 * b16 - 0.004166666666666667 * b17 - 0.001388888888888889 * b18 + 0.006944444444444444 * b19 - 0.006944444444444444 * b2 - 0.01388888888888889 * b20 + 0.01388888888888889 * b21 - 0.006944444444444444 * b22 + 0.001388888888888889 * b23 - 0.0006944444444444444 * b24 + 0.003472222222222222 * b25 - 0.006944444444444444 * b26 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.0006944444444444444 * b29 + 0.006944444444444444 * b3 - 0.003472222222222222 * b4 + 0.0006944444444444444 * b5 - 0.001388888888888889 * b6 + 0.006944444444444444 * b7 - 0.01388888888888889 * b8 + 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 18] = 0.001388888888888889 * b10 - 0.01805555555555556 * b1 - 0.0006944444444444444 * b0 - 0.001388888888888889 * b18 - 0.03611111111111111 * b19 - 0.04583333333333333 * b2 - 0.09166666666666667 * b20 - 0.03611111111111111 * b21 - 0.001388888888888889 * b22 + 0.0006944444444444444 * b24 + 0.01805555555555556 * b25 + 0.04583333333333333 * b26 + 0.01805555555555556 * b27 + 0.0006944444444444444 * b28 - 0.01805555555555556 * b3 - 0.0006944444444444444 * b4 + 0.001388888888888889 * b6 + 0.03611111111111111 * b7 + 0.09166666666666667 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 19] = 0.003472222222222222 * b0 + 0.03472222222222222 * b1 + 0.006944444444444444 * b10 + 0.006944444444444444 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 - 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.03472222222222222 * b25 + 0.03472222222222222 * b27 + 0.003472222222222222 * b28 - 0.03472222222222222 * b3 - 0.003472222222222222 * b4 - 0.006944444444444444 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 20] = 0.01388888888888889 * b10 - 0.01388888888888889 * b1 - 0.006944444444444444 * b0 - 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.04166666666666667 * b2 + 0.08333333333333333 * b20 - 0.02777777777777778 * b21 - 0.01388888888888889 * b22 + 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.04166666666666667 * b26 + 0.01388888888888889 * b27 + 0.006944444444444444 * b28 - 0.01388888888888889 * b3 - 0.006944444444444444 * b4 + 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.08333333333333333 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 21] = 0.006944444444444444 * b0 - 0.01388888888888889 * b1 + 0.01388888888888889 * b10 + 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.02777777777777778 * b21 - 0.01388888888888889 * b22 - 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.01388888888888889 * b27 + 0.006944444444444444 * b28 + 0.01388888888888889 * b3 - 0.006944444444444444 * b4 - 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 22] = 0.01388888888888889 * b1 - 0.003472222222222222 * b0 + 0.006944444444444444 * b10 - 0.006944444444444444 * b18 + 0.02777777777777778 * b19 - 0.02083333333333333 * b2 - 0.04166666666666667 * b20 + 0.02777777777777778 * b21 - 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.01388888888888889 * b25 + 0.02083333333333333 * b26 - 0.01388888888888889 * b27 + 0.003472222222222222 * b28 + 0.01388888888888889 * b3 - 0.003472222222222222 * b4 + 0.006944444444444444 * b6 - 0.02777777777777778 * b7 + 0.04166666666666667 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 23] = 0.0006944444444444444 * b0 - 0.003472222222222222 * b1 - 0.006944444444444444 * b10 + 0.001388888888888889 * b11 + 0.001388888888888889 * b18 - 0.006944444444444444 * b19 + 0.006944444444444444 * b2 + 0.01388888888888889 * b20 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.001388888888888889 * b23 - 0.0006944444444444444 * b24 + 0.003472222222222222 * b25 - 0.006944444444444444 * b26 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.0006944444444444444 * b29 - 0.006944444444444444 * b3 + 0.003472222222222222 * b4 - 0.0006944444444444444 * b5 - 0.001388888888888889 * b6 + 0.006944444444444444 * b7 - 0.01388888888888889 * b8 + 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 24] = 0.0003472222222222222 * b0 + 0.009027777777777778 * b1 - 0.001388888888888889 * b10 + 0.002083333333333333 * b12 + 0.05416666666666667 * b13 + 0.1375 * b14 + 0.05416666666666667 * b15 + 0.002083333333333333 * b16 - 0.001388888888888889 * b18 - 0.03611111111111111 * b19 + 0.02291666666666667 * b2 - 0.09166666666666667 * b20 - 0.03611111111111111 * b21 - 0.001388888888888889 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 + 0.009027777777777778 * b3 + 0.0003472222222222222 * b4 - 0.001388888888888889 * b6 - 0.03611111111111111 * b7 - 0.09166666666666667 * b8 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 25] = 0.1041666666666667 * b15 - 0.01736111111111111 * b1 - 0.006944444444444444 * b10 - 0.01041666666666667 * b12 - 0.1041666666666667 * b13 - 0.001736111111111111 * b0 + 0.01041666666666667 * b16 + 0.006944444444444444 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 - 0.006944444444444444 * b22 - 0.001736111111111111 * b24 - 0.01736111111111111 * b25 + 0.01736111111111111 * b27 + 0.001736111111111111 * b28 + 0.01736111111111111 * b3 + 0.001736111111111111 * b4 + 0.006944444444444444 * b6 + 0.06944444444444444 * b7 - 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 26] = 0.003472222222222222 * b0 + 0.006944444444444444 * b1 - 0.01388888888888889 * b10 + 0.02083333333333333 * b12 + 0.04166666666666667 * b13 - 0.125 * b14 + 0.04166666666666667 * b15 + 0.02083333333333333 * b16 - 0.01388888888888889 * b18 - 0.02777777777777778 * b19 - 0.02083333333333333 * b2 + 0.08333333333333333 * b20 - 0.02777777777777778 * b21 - 0.01388888888888889 * b22 + 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.02083333333333333 * b26 + 0.006944444444444444 * b27 + 0.003472222222222222 * b28 + 0.006944444444444444 * b3 + 0.003472222222222222 * b4 - 0.01388888888888889 * b6 - 0.02777777777777778 * b7 + 0.08333333333333333 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 27] = 0.006944444444444444 * b1 - 0.003472222222222222 * b0 - 0.01388888888888889 * b10 - 0.02083333333333333 * b12 + 0.04166666666666667 * b13 - 0.04166666666666667 * b15 + 0.02083333333333333 * b16 + 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.02777777777777778 * b21 - 0.01388888888888889 * b22 - 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.006944444444444444 * b27 + 0.003472222222222222 * b28 - 0.006944444444444444 * b3 + 0.003472222222222222 * b4 + 0.01388888888888889 * b6 - 0.02777777777777778 * b7 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 28] = 0.001736111111111111 * b0 - 0.006944444444444444 * b1 - 0.006944444444444444 * b10 + 0.01041666666666667 * b12 - 0.04166666666666667 * b13 + 0.0625 * b14 - 0.04166666666666667 * b15 + 0.01041666666666667 * b16 - 0.006944444444444444 * b18 + 0.02777777777777778 * b19 + 0.01041666666666667 * b2 - 0.04166666666666667 * b20 + 0.02777777777777778 * b21 - 0.006944444444444444 * b22 + 0.001736111111111111 * b24 - 0.006944444444444444 * b25 + 0.01041666666666667 * b26 - 0.006944444444444444 * b27 + 0.001736111111111111 * b28 - 0.006944444444444444 * b3 + 0.001736111111111111 * b4 - 0.006944444444444444 * b6 + 0.02777777777777778 * b7 - 0.04166666666666667 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 29] = 0.001736111111111111 * b1 - 0.0003472222222222222 * b0 + 0.006944444444444444 * b10 - 0.001388888888888889 * b11 - 0.002083333333333333 * b12 + 0.01041666666666667 * b13 - 0.02083333333333333 * b14 + 0.02083333333333333 * b15 - 0.01041666666666667 * b16 + 0.002083333333333333 * b17 + 0.001388888888888889 * b18 - 0.006944444444444444 * b19 - 0.003472222222222222 * b2 + 0.01388888888888889 * b20 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.001388888888888889 * b23 - 0.0003472222222222222 * b24 + 0.001736111111111111 * b25 - 0.003472222222222222 * b26 + 0.003472222222222222 * b27 - 0.001736111111111111 * b28 + 0.0003472222222222222 * b29 + 0.003472222222222222 * b3 - 0.001736111111111111 * b4 + 0.0003472222222222222 * b5 + 0.001388888888888889 * b6 - 0.006944444444444444 * b7 + 0.01388888888888889 * b8 - 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 30] = 0.0003472222222222222 * b10 - 0.001805555555555556 * b1 - 0.00006944444444444444 * b0 - 0.0006944444444444444 * b12 - 0.01805555555555556 * b13 - 0.04583333333333333 * b14 - 0.01805555555555556 * b15 - 0.0006944444444444444 * b16 + 0.0006944444444444444 * b18 + 0.01805555555555556 * b19 - 0.004583333333333333 * b2 + 0.04583333333333333 * b20 + 0.01805555555555556 * b21 + 0.0006944444444444444 * b22 - 0.0003472222222222222 * b24 - 0.009027777777777778 * b25 - 0.02291666666666667 * b26 - 0.009027777777777778 * b27 - 0.0003472222222222222 * b28 - 0.001805555555555556 * b3 + 0.00006944444444444444 * b30 + 0.001805555555555556 * b31 + 0.004583333333333333 * b32 + 0.001805555555555556 * b33 + 0.00006944444444444444 * b34 - 0.00006944444444444444 * b4 + 0.0003472222222222222 * b6 + 0.009027777777777778 * b7 + 0.02291666666666667 * b8 + 0.009027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 31] = 0.0003472222222222222 * b0 + 0.003472222222222222 * b1 + 0.001736111111111111 * b10 + 0.003472222222222222 * b12 + 0.03472222222222222 * b13 - 0.03472222222222222 * b15 - 0.003472222222222222 * b16 - 0.003472222222222222 * b18 - 0.03472222222222222 * b19 + 0.03472222222222222 * b21 + 0.003472222222222222 * b22 + 0.001736111111111111 * b24 + 0.01736111111111111 * b25 - 0.01736111111111111 * b27 - 0.001736111111111111 * b28 - 0.003472222222222222 * b3 - 0.0003472222222222222 * b30 - 0.003472222222222222 * b31 + 0.003472222222222222 * b33 + 0.0003472222222222222 * b34 - 0.0003472222222222222 * b4 - 0.001736111111111111 * b6 - 0.01736111111111111 * b7 + 0.01736111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 32] = 0.003472222222222222 * b10 - 0.001388888888888889 * b1 - 0.0006944444444444444 * b0 - 0.006944444444444444 * b12 - 0.01388888888888889 * b13 + 0.04166666666666667 * b14 - 0.01388888888888889 * b15 - 0.006944444444444444 * b16 + 0.006944444444444444 * b18 + 0.01388888888888889 * b19 + 0.004166666666666667 * b2 - 0.04166666666666667 * b20 + 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.006944444444444444 * b25 + 0.02083333333333333 * b26 - 0.006944444444444444 * b27 - 0.003472222222222222 * b28 - 0.001388888888888889 * b3 + 0.0006944444444444444 * b30 + 0.001388888888888889 * b31 - 0.004166666666666667 * b32 + 0.001388888888888889 * b33 + 0.0006944444444444444 * b34 - 0.0006944444444444444 * b4 + 0.003472222222222222 * b6 + 0.006944444444444444 * b7 - 0.02083333333333333 * b8 + 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 33] = 0.0006944444444444444 * b0 - 0.001388888888888889 * b1 + 0.003472222222222222 * b10 + 0.006944444444444444 * b12 - 0.01388888888888889 * b13 + 0.01388888888888889 * b15 - 0.006944444444444444 * b16 - 0.006944444444444444 * b18 + 0.01388888888888889 * b19 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.006944444444444444 * b25 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.001388888888888889 * b3 - 0.0006944444444444444 * b30 + 0.001388888888888889 * b31 - 0.001388888888888889 * b33 + 0.0006944444444444444 * b34 - 0.0006944444444444444 * b4 - 0.003472222222222222 * b6 + 0.006944444444444444 * b7 - 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 34] = 0.001388888888888889 * b1 - 0.0003472222222222222 * b0 + 0.001736111111111111 * b10 - 0.003472222222222222 * b12 + 0.01388888888888889 * b13 - 0.02083333333333333 * b14 + 0.01388888888888889 * b15 - 0.003472222222222222 * b16 + 0.003472222222222222 * b18 - 0.01388888888888889 * b19 - 0.002083333333333333 * b2 + 0.02083333333333333 * b20 - 0.01388888888888889 * b21 + 0.003472222222222222 * b22 - 0.001736111111111111 * b24 + 0.006944444444444444 * b25 - 0.01041666666666667 * b26 + 0.006944444444444444 * b27 - 0.001736111111111111 * b28 + 0.001388888888888889 * b3 + 0.0003472222222222222 * b30 - 0.001388888888888889 * b31 + 0.002083333333333333 * b32 - 0.001388888888888889 * b33 + 0.0003472222222222222 * b34 - 0.0003472222222222222 * b4 + 0.001736111111111111 * b6 - 0.006944444444444444 * b7 + 0.01041666666666667 * b8 - 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 35] = 0.00006944444444444444 * b0 - 0.0003472222222222222 * b1 - 0.001736111111111111 * b10 + 0.0003472222222222222 * b11 + 0.0006944444444444444 * b12 - 0.003472222222222222 * b13 + 0.006944444444444444 * b14 - 0.006944444444444444 * b15 + 0.003472222222222222 * b16 - 0.0006944444444444444 * b17 - 0.0006944444444444444 * b18 + 0.003472222222222222 * b19 + 0.0006944444444444444 * b2 - 0.006944444444444444 * b20 + 0.006944444444444444 * b21 - 0.003472222222222222 * b22 + 0.0006944444444444444 * b23 + 0.0003472222222222222 * b24 - 0.001736111111111111 * b25 + 0.003472222222222222 * b26 - 0.003472222222222222 * b27 + 0.001736111111111111 * b28 - 0.0003472222222222222 * b29 - 0.0006944444444444444 * b3 - 0.00006944444444444444 * b30 + 0.0003472222222222222 * b31 - 0.0006944444444444444 * b32 + 0.0006944444444444444 * b33 - 0.0003472222222222222 * b34 + 0.00006944444444444444 * b35 + 0.0003472222222222222 * b4 - 0.00006944444444444444 * b5 - 0.0003472222222222222 * b6 + 0.001736111111111111 * b7 - 0.003472222222222222 * b8 + 0.003472222222222222 * b9;
        }
    }
}

void Dic::analysis(std::ofstream &of, std::size_t currImg) {
    //    of << "Inside analysis for current image " << currImg << "\n";
    int spacing = params.subsetSpacing;
    //    of << "Total regions are " << roi.region.size() << "\n";
    for (std::size_t num_region = 0; num_region < roi.region.size(); num_region++) {
        //        of << "Updating cirroi for region " << num_region << "\n";
        roi.update_cirroi(num_region);

        //        of << "Initialize queue\n";
        heap queue;
        //        of << "Creating file for separate qorder list\n";
        //        std::ofstream qf(QString("./qorder%1.txt").arg(currImg).toStdString());

        // Add seed to queue
        // [x y u v du/dx du/dy dv/dx dv/dy corrcoef]
        std::vector<double> paramvector_seed(9, 0);

        // seed is to be used here
        paramvector_seed[0] = seed_info[currImg][0];
        paramvector_seed[1] = seed_info[currImg][1];
        paramvector_seed[2] = seed_info[currImg][2];
        paramvector_seed[3] = seed_info[currImg][3];
        paramvector_seed[4] = seed_info[currImg][4];
        paramvector_seed[5] = seed_info[currImg][5];
        paramvector_seed[6] = seed_info[currImg][6];
        paramvector_seed[7] = seed_info[currImg][7];
        paramvector_seed[8] = seed_info[currImg][8];
        queue.push(paramvector_seed);

        //        of << "Seed added to queue with values : ";
        //        for (const auto &e : paramvector_seed)
        //            of << e << " ";
        //        of << "\n";

        //        of << "Inactivate seed point and mark it as calculated and valid\n";
        int x_seed_reduced = static_cast<int>(paramvector_seed[0]) / (spacing + 1); // x_seed and y_seed are guaranteed divisible by (spacing+1)
        int y_seed_reduced = static_cast<int>(paramvector_seed[1]) / (spacing + 1);
        plot_calcpoints.value[y_seed_reduced + x_seed_reduced * plot_calcpoints.height] = true;
        plot_validpoints[currImg].value[y_seed_reduced + x_seed_reduced * plot_validpoints[currImg].height] = true;

        //        of << "Starting while loop for queue\n";
        // Enter While Loop - Exit when queue is empty
        while (!queue.empty()) {
            // 1) Load point with lowest correlation coefficient from queue
            // 2) Delete point from queue
            // 3) Add data to plots
            // 4) Analyze four surrounding points and sort

            // Step 1: load
            std::vector<double> paramvector_init = queue.top();

            //of <<  "Queue pop at : ";
            //            for (const auto &e : paramvector_init) {
            //of <<  e << " ";
            //                qf << e << " ";
            //            }
            //of <<  "\n";

            // Step 2: delete
            queue.pop();
            of << paramvector_init[0] << ", " << paramvector_init[1] << "\n";

            // Step 3: add data to plots
            int x_init_reduced = static_cast<int>(paramvector_init[0]) / (spacing + 1);
            int y_init_reduced = static_cast<int>(paramvector_init[1]) / (spacing + 1);
            plot_u[currImg].value[y_init_reduced + x_init_reduced * plot_u[currImg].height] = paramvector_init[2];
            plot_v[currImg].value[y_init_reduced + x_init_reduced * plot_v[currImg].height] = paramvector_init[3];
            plot_corrcoef[currImg].value[y_init_reduced + x_init_reduced * plot_corrcoef[currImg].height] = paramvector_init[8];

            //            of << "Analysing surroinding points of (" << paramvector_init[0] << ", " << paramvector_init[1] << ")\n";
            // Step 4: analyze four surrounding points - must increment by spacing parameter
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]), static_cast<int>(paramvector_init[1]) - (spacing + 1), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]) + (spacing + 1), static_cast<int>(paramvector_init[1]), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]), static_cast<int>(paramvector_init[1]) + (spacing + 1), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]) - (spacing + 1), static_cast<int>(paramvector_init[1]), paramvector_init, num_region);
        }
    }
}

void Dic::analyzepoint(std::ofstream &of, std::size_t currImg, heap &queue, const int &x, const int &y, const std::vector<double> &paramvector_init, const int &num_region) {
    int spacing = params.subsetSpacing;

    // These are read only, so they are thread safe
    static double cutoff_corrcoef = 2.0;     // Heuristic, but 2.0 is pretty high. Range is [0,4]. Different images can have different corrcoef cutoffs which work well, so set this to a low value
    static double cutoff_disp = spacing + 1; // Heuristic, this prevents large displacement jumps (most likely incorrect data) form being added

    // Reduce coordinates first
    int x_reduced = x / (spacing + 1);
    int y_reduced = y / (spacing + 1);
    //of <<  "Analysing point (" << x << ", " << y << "), reduced version (" << x_reduced << ", " << y_reduced << ")\n";

    // Make sure point is within region bounds first
    if (x >= roi.region[num_region].leftbound &&
        x <= roi.region[num_region].rightbound &&
        y >= roi.region[num_region].upperbound &&
        y <= roi.region[num_region].lowerbound &&
        !plot_calcpoints.value[y_reduced + x_reduced * plot_calcpoints.height] &&
        roi.withinregion(x, y, num_region)) {
        //of <<  "Point was within region bounds. Ok to proceed\n";

        // Initialize paramvector
        std::vector<double> paramvector(9, 0); // [x y u v du/dx du/dy dv/dx dv/dy corrcoef]

        //of <<  "Calling calpoint for this point\n";
        // Calculate paramvector for a point
        bool outstate = calcpoint(of, currImg, paramvector, x, y, paramvector_init, num_region);

        // Make sure parameters are correct before adding them to queue
        if (outstate &&
            paramvector[8] < cutoff_corrcoef &&
            fabs(paramvector_init[2] - paramvector[2]) < cutoff_disp &&
            fabs(paramvector_init[3] - paramvector[3]) < cutoff_disp) {
            // Insert paramvector based on correlation coefficient
            //            of << "Calcpoint was success!\n";
            queue.push(paramvector);

            // Valid Point
            plot_validpoints[currImg].value[y_reduced + x_reduced * plot_validpoints[currImg].height] = true;
        } else {
            //            of << "Calcpoint failed.\n";
        }
        // Calculated point
        plot_calcpoints.value[y_reduced + x_reduced * plot_calcpoints.height] = true;
    } else {
        //        of << "Point not in region. Wrong point.\n";
    }
}

bool Dic::calcpoint(std::ofstream &of, std::size_t currImg, std::vector<double> &paramvector, const int &x, const int &y, const std::vector<double> &paramvector_init, const int &num_region) {
    // Get cirroi -> Find initial guess -> Refine results with IC-GN -> Return true or false and store output
    // Step 1: Get cirroi
    //subsettrunc = false
    //of <<  "Called get cirroi for (" << x << ", " << y << ") point\n";
    roi.get_cirroi(x, y, num_region, false);

    // Step 2: Get initial guess - Use displacement and displacement gradients to get initial guess
    std::vector<double> defvector_init(6, 0); // [u v du/dx du/dy dv/dx dv/dy]
    // u_init = u+du/dx*x_delta+du/dy*y_delta;
    // v_init = v+dv/dx*x_delta+dv/dy*y_delta;
    defvector_init[0] = paramvector_init[2] + paramvector_init[4] * (x - paramvector_init[0]) + paramvector_init[5] * (y - paramvector_init[1]);
    defvector_init[1] = paramvector_init[3] + paramvector_init[6] * (x - paramvector_init[0]) + paramvector_init[7] * (y - paramvector_init[1]);
    defvector_init[2] = paramvector_init[4];
    defvector_init[3] = paramvector_init[5];
    defvector_init[4] = paramvector_init[6];
    defvector_init[5] = paramvector_init[7];

    // Step 3: Get refined results with IC-GN
    std::vector<double> defvector(6, 0); // [u v du/dx du/dy dv/dx dv/dy]
    double corrcoef;
    //of <<  "Getting corr using iterative search\n";
    bool outstate_iterative = iterativesearch(of, currImg, defvector, corrcoef, defvector_init);

    if (outstate_iterative) {
        // Step 4: Store output and return true
        paramvector[0] = x;
        paramvector[1] = y;
        paramvector[2] = defvector[0];
        paramvector[3] = defvector[1];
        paramvector[4] = defvector[2];
        paramvector[5] = defvector[3];
        paramvector[6] = defvector[4];
        paramvector[7] = defvector[5];
        paramvector[8] = corrcoef;
        //of <<  "Iterative search pass and calcpoint success\n";
        //of <<  "Corr was " << corrcoef << "\n";
        return true;
    }
    //of <<  "Iterative search failed!\n";
    return false;
}

bool Dic::iterativesearch(std::ofstream &of, std::size_t currImg, std::vector<double> &defvector, double &corrcoef, const std::vector<double> &defvector_init) {

    // Calculate fm
    double fm = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_ref = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                fm += rimg.gs.value[lind_ref];
            }
        }
    }
    fm = fm / (double)roi.cirroi.region.totalpoints;
    //of << "fm is " << fm << "\n";

    // Calculate deltaf_inf
    double deltaf_inv = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_ref = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                deltaf_inv += pow(rimg.gs.value[lind_ref] - fm, 2);
            }
        }
    }
    deltaf_inv = sqrt(deltaf_inv);
    //of <<  "delta inf " << deltaf_inv << "\n";

    // check to make sure deltaf_inv (strictly positive) isn't close to zero; if it is, iterative search fails
    if (deltaf_inv > LAMBDA) {
        // Finish deltaf_inv
        deltaf_inv = 1.0 / deltaf_inv;

        // Precompute "Steepest descent images"
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Find new coordinates
                    double dx = (double)(i - roi.cirroi.radius);
                    double dy = (double)(k - roi.cirroi.y);

                    int y_tilda_floor = k;
                    int x_tilda_floor = i + (roi.cirroi.x - roi.cirroi.radius);

                    // Calculate lind_f for gradient and lind_df for the first order "steepest descent images"
                    int lind_f = y_tilda_floor + x_tilda_floor * rimg.gs.height;
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);

                    // First order
                    df_dp_buffer[lind_df] = df_dx_buffer[lind_f];          // u
                    df_dp_buffer[lind_df + 1] = df_dy_buffer[lind_f];      // v
                    df_dp_buffer[lind_df + 2] = df_dx_buffer[lind_f] * dx; // dudx
                    df_dp_buffer[lind_df + 3] = df_dx_buffer[lind_f] * dy; // dudy
                    df_dp_buffer[lind_df + 4] = df_dy_buffer[lind_f] * dx; // dvdx
                    df_dp_buffer[lind_df + 5] = df_dy_buffer[lind_f] * dy; // dvdy
                }
            }
        }

        // Precompute GN hessian
        // Initialize to zero first
        std::fill(hessian_gn_buffer.begin(), hessian_gn_buffer.end(), 0.0);
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Parameters
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);

                    // Hessian - only calculate lower half since hessian is symmetric
                    hessian_gn_buffer[0] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df];
                    hessian_gn_buffer[1] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 1];
                    hessian_gn_buffer[2] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[3] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[4] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[5] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[7] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 1];
                    hessian_gn_buffer[8] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[9] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[10] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[11] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[14] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[15] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[16] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[17] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[21] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[22] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[23] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[28] += df_dp_buffer[lind_df + 4] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[29] += df_dp_buffer[lind_df + 4] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[35] += df_dp_buffer[lind_df + 5] * df_dp_buffer[lind_df + 5];
                }
            }
        }

        // Multiply components of hessian by 2/deltaf^2
        for (int i = 0; i < 6; i++) {
            for (int j = i; j < 6; j++) {
                hessian_gn_buffer[j + i * 6] *= 2 * pow(deltaf_inv, 2);
            }
        }

        // Fill other half of hessian
        hessian_gn_buffer[6] = hessian_gn_buffer[1];

        hessian_gn_buffer[12] = hessian_gn_buffer[2];
        hessian_gn_buffer[13] = hessian_gn_buffer[8];

        hessian_gn_buffer[18] = hessian_gn_buffer[3];
        hessian_gn_buffer[19] = hessian_gn_buffer[9];
        hessian_gn_buffer[20] = hessian_gn_buffer[15];

        hessian_gn_buffer[24] = hessian_gn_buffer[4];
        hessian_gn_buffer[25] = hessian_gn_buffer[10];
        hessian_gn_buffer[26] = hessian_gn_buffer[16];
        hessian_gn_buffer[27] = hessian_gn_buffer[22];

        hessian_gn_buffer[30] = hessian_gn_buffer[5];
        hessian_gn_buffer[31] = hessian_gn_buffer[11];
        hessian_gn_buffer[32] = hessian_gn_buffer[17];
        hessian_gn_buffer[33] = hessian_gn_buffer[23];
        hessian_gn_buffer[34] = hessian_gn_buffer[29];

        // Solve for new parameters via cholesky decomp (from Golub and Van Loan)
        // Lower triangle of Hessian overwritten with parameters used in Cholesky decomp
        // If one of the diagonals is close to zero or negative, then the
        // hessian is not positive definite
        bool positivedef = true;
        dicutils::cholesky(hessian_gn_buffer, positivedef, 6);

        if (positivedef) {
            // Start iterations - For first iteration use defvector_init
            double diffnorm;
            bool outstate_newton = newton(of, currImg, defvector, corrcoef, diffnorm, defvector_init, fm, deltaf_inv);

            // Initialize counter
            int counter = 1;
            while (outstate_newton && diffnorm >= params.cutoff_diffnorm && counter <= params.cutoff_iteration) {
                // For rest of iterations use defvector from previous iterations
                outstate_newton = newton(of, currImg, defvector, corrcoef, diffnorm, defvector, fm, deltaf_inv);
                ++counter;
            }

            if (outstate_newton) {
                return true;
            }
        }
    }
    // Some parameters are invalid - either deltag_inv was zero or the hessian wasn't positive definite
    return false;
}

bool Dic::newton(std::ofstream &of, std::size_t currImg, std::vector<double> &defvector, double &corrcoef, double &diffnorm, const std::vector<double> &defvector_init, const double &fm, const double &deltaf_inv) {
    // Will only overwrite queue_new if parameters are valid
    // Interpolate g subset - do this here instead of interp_qbs because QK_B_QKT has been precomputed
    double gm = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                // Find new coordinates
                double dx = (double)(i - roi.cirroi.radius);
                double dy = (double)(k - roi.cirroi.y);

                double y_tilda = (double)k + defvector_init[1] + defvector_init[4] * dx + defvector_init[5] * dy;
                double x_tilda = (double)(i + (roi.cirroi.x - roi.cirroi.radius)) + defvector_init[0] + defvector_init[2] * dx + defvector_init[3] * dy;

                int x_tilda_floor = (int)floor(x_tilda);
                int y_tilda_floor = (int)floor(y_tilda);

                int lind_g = (int)dy + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;

                // Get bounds of the desired b-spline coefficients used for interpolation
                int top = y_tilda_floor + cimgs[currImg].border_bcoef - 2;
                int left = x_tilda_floor + cimgs[currImg].border_bcoef - 2;
                int bottom = y_tilda_floor + cimgs[currImg].border_bcoef + 3;
                int right = x_tilda_floor + cimgs[currImg].border_bcoef + 3;

                if (top >= 0 &&
                    left >= 0 &&
                    bottom < cimgs[currImg].bcoef.height &&
                    right < cimgs[currImg].bcoef.width) {
                    double x_tilda_delta = x_tilda - (double)x_tilda_floor;
                    double y_tilda_delta = y_tilda - (double)y_tilda_floor;

                    // Form x_vec
                    x_vec_buffer[1] = x_tilda_delta;
                    x_vec_buffer[2] = x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[3] = x_tilda_delta * x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[4] = x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[5] = x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta;

                    // Form y_vec
                    y_vec_buffer[1] = y_tilda_delta;
                    y_vec_buffer[2] = y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[3] = y_tilda_delta * y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[4] = y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[5] = y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta;

                    // Calculate lind_qkbqkt for QK_B_QKT
                    int lind_qkbqkt = (top * 36) + (left * 36 * (cimgs[currImg].bcoef.height - 5));

                    // Get QK_B_QKT coefficients
                    double QK_B_QKT_0 = QK_B_QKT_buffer[lind_qkbqkt];
                    double QK_B_QKT_1 = QK_B_QKT_buffer[lind_qkbqkt + 1];
                    double QK_B_QKT_2 = QK_B_QKT_buffer[lind_qkbqkt + 2];
                    double QK_B_QKT_3 = QK_B_QKT_buffer[lind_qkbqkt + 3];
                    double QK_B_QKT_4 = QK_B_QKT_buffer[lind_qkbqkt + 4];
                    double QK_B_QKT_5 = QK_B_QKT_buffer[lind_qkbqkt + 5];
                    double QK_B_QKT_6 = QK_B_QKT_buffer[lind_qkbqkt + 6];
                    double QK_B_QKT_7 = QK_B_QKT_buffer[lind_qkbqkt + 7];
                    double QK_B_QKT_8 = QK_B_QKT_buffer[lind_qkbqkt + 8];
                    double QK_B_QKT_9 = QK_B_QKT_buffer[lind_qkbqkt + 9];
                    double QK_B_QKT_10 = QK_B_QKT_buffer[lind_qkbqkt + 10];
                    double QK_B_QKT_11 = QK_B_QKT_buffer[lind_qkbqkt + 11];
                    double QK_B_QKT_12 = QK_B_QKT_buffer[lind_qkbqkt + 12];
                    double QK_B_QKT_13 = QK_B_QKT_buffer[lind_qkbqkt + 13];
                    double QK_B_QKT_14 = QK_B_QKT_buffer[lind_qkbqkt + 14];
                    double QK_B_QKT_15 = QK_B_QKT_buffer[lind_qkbqkt + 15];
                    double QK_B_QKT_16 = QK_B_QKT_buffer[lind_qkbqkt + 16];
                    double QK_B_QKT_17 = QK_B_QKT_buffer[lind_qkbqkt + 17];
                    double QK_B_QKT_18 = QK_B_QKT_buffer[lind_qkbqkt + 18];
                    double QK_B_QKT_19 = QK_B_QKT_buffer[lind_qkbqkt + 19];
                    double QK_B_QKT_20 = QK_B_QKT_buffer[lind_qkbqkt + 20];
                    double QK_B_QKT_21 = QK_B_QKT_buffer[lind_qkbqkt + 21];
                    double QK_B_QKT_22 = QK_B_QKT_buffer[lind_qkbqkt + 22];
                    double QK_B_QKT_23 = QK_B_QKT_buffer[lind_qkbqkt + 23];
                    double QK_B_QKT_24 = QK_B_QKT_buffer[lind_qkbqkt + 24];
                    double QK_B_QKT_25 = QK_B_QKT_buffer[lind_qkbqkt + 25];
                    double QK_B_QKT_26 = QK_B_QKT_buffer[lind_qkbqkt + 26];
                    double QK_B_QKT_27 = QK_B_QKT_buffer[lind_qkbqkt + 27];
                    double QK_B_QKT_28 = QK_B_QKT_buffer[lind_qkbqkt + 28];
                    double QK_B_QKT_29 = QK_B_QKT_buffer[lind_qkbqkt + 29];
                    double QK_B_QKT_30 = QK_B_QKT_buffer[lind_qkbqkt + 30];
                    double QK_B_QKT_31 = QK_B_QKT_buffer[lind_qkbqkt + 31];
                    double QK_B_QKT_32 = QK_B_QKT_buffer[lind_qkbqkt + 32];
                    double QK_B_QKT_33 = QK_B_QKT_buffer[lind_qkbqkt + 33];
                    double QK_B_QKT_34 = QK_B_QKT_buffer[lind_qkbqkt + 34];
                    double QK_B_QKT_35 = QK_B_QKT_buffer[lind_qkbqkt + 35];

                    // Calculate g - main computational bottleneck of the inverse compositional method with biquintic b-splines
                    g_buffer[lind_g] = (QK_B_QKT_0 + x_vec_buffer[1] * QK_B_QKT_6 + x_vec_buffer[2] * QK_B_QKT_12 + x_vec_buffer[3] * QK_B_QKT_18 + x_vec_buffer[4] * QK_B_QKT_24 + x_vec_buffer[5] * QK_B_QKT_30) +
                                       (QK_B_QKT_1 + x_vec_buffer[1] * QK_B_QKT_7 + x_vec_buffer[2] * QK_B_QKT_13 + x_vec_buffer[3] * QK_B_QKT_19 + x_vec_buffer[4] * QK_B_QKT_25 + x_vec_buffer[5] * QK_B_QKT_31) * y_vec_buffer[1] +
                                       (QK_B_QKT_2 + x_vec_buffer[1] * QK_B_QKT_8 + x_vec_buffer[2] * QK_B_QKT_14 + x_vec_buffer[3] * QK_B_QKT_20 + x_vec_buffer[4] * QK_B_QKT_26 + x_vec_buffer[5] * QK_B_QKT_32) * y_vec_buffer[2] +
                                       (QK_B_QKT_3 + x_vec_buffer[1] * QK_B_QKT_9 + x_vec_buffer[2] * QK_B_QKT_15 + x_vec_buffer[3] * QK_B_QKT_21 + x_vec_buffer[4] * QK_B_QKT_27 + x_vec_buffer[5] * QK_B_QKT_33) * y_vec_buffer[3] +
                                       (QK_B_QKT_4 + x_vec_buffer[1] * QK_B_QKT_10 + x_vec_buffer[2] * QK_B_QKT_16 + x_vec_buffer[3] * QK_B_QKT_22 + x_vec_buffer[4] * QK_B_QKT_28 + x_vec_buffer[5] * QK_B_QKT_34) * y_vec_buffer[4] +
                                       (QK_B_QKT_5 + x_vec_buffer[1] * QK_B_QKT_11 + x_vec_buffer[2] * QK_B_QKT_17 + x_vec_buffer[3] * QK_B_QKT_23 + x_vec_buffer[4] * QK_B_QKT_29 + x_vec_buffer[5] * QK_B_QKT_35) * y_vec_buffer[5];

                    // Add components to calculate the mean
                    gm += g_buffer[lind_g];
                } else {
                    // If this condition is satisfied then we are
                    // interpolating a point beyond the bounds of the
                    // original image, so just set the values to zero
                    g_buffer[lind_g] = 0.0;

                    // Don't add anything to averages
                    continue;
                }
            }
        }
    }
    // Divide by totalpoints to get real average
    gm /= static_cast<double>(roi.cirroi.region.totalpoints);

    // Calculate deltag_inv
    double deltag_inv = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_g = (k - roi.cirroi.y) + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;
                deltag_inv = deltag_inv + pow(g_buffer[lind_g] - gm, 2);
            }
        }
    }
    deltag_inv = sqrt(deltag_inv); // This is deltag; will take inverse after ensuring it is not close to zero

    // check to make sure deltag_inv (strictly positive) isn't close to zero; if it is, exit newton raphson
    if (deltag_inv > LAMBDA) {
        // Finish deltag_inv
        deltag_inv = 1.0 / deltag_inv;

        // Calculate gradient
        // Initialize to zero first
        std::fill(gradient_buffer.begin(), gradient_buffer.end(), 0.0);
        corrcoef = 0.0;
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Parameters
                    int lind_f = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);
                    int lind_g = (k - roi.cirroi.y) + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;

                    // Gradient Parameters
                    double normalized_diff = (rimg.gs.value[lind_f] - fm) * deltaf_inv - (g_buffer[lind_g] - gm) * deltag_inv;

                    // Gradient
                    gradient_buffer[0] += normalized_diff * df_dp_buffer[lind_df];
                    gradient_buffer[1] += normalized_diff * df_dp_buffer[lind_df + 1];
                    gradient_buffer[2] += normalized_diff * df_dp_buffer[lind_df + 2];
                    gradient_buffer[3] += normalized_diff * df_dp_buffer[lind_df + 3];
                    gradient_buffer[4] += normalized_diff * df_dp_buffer[lind_df + 4];
                    gradient_buffer[5] += normalized_diff * df_dp_buffer[lind_df + 5];

                    // Correlation coefficient
                    corrcoef += pow(normalized_diff, 2);
                }
            }
        }

        // Update gradient; multiply by the inverses
        for (int i = 0; i < 6; i++) {
            gradient_buffer[i] *= 2 * deltaf_inv;
        }

        // Find new change in deformation parameters
        // Ax = b
        // GG'x = b, where G is lower triangular
        // Gy = b -> G'x = y
        // Step 1: solve for y with forward substitution; y is stored in gradient_buffer
        dicutils::forwardsub(gradient_buffer, hessian_gn_buffer, 6);

        // Step 2: solve for x with back substitution
        dicutils::backwardsub(gradient_buffer, hessian_gn_buffer, 6);

        // Make gradient_buffer negative
        for (int i = 0; i < 6; i++) {
            gradient_buffer[i] = -gradient_buffer[i];
        }

        // At this point the change in deformation parameters is stored in gradient_buffer
        // Calculate difference norm - this is stored in gradient_buffer at this point
        diffnorm = 0.0;
        for (int i = 0; i < 6; i++) {
            diffnorm += gradient_buffer[i] * gradient_buffer[i];
        }
        diffnorm = sqrt(diffnorm);

        // Update parameters using inverse composition
        // Transfer parameters because defvector_init is an alias of defvector after the first iteration
        double defvector_init_u = defvector_init[0];
        double defvector_init_v = defvector_init[1];
        double defvector_init_dudx = defvector_init[2];
        double defvector_init_dudy = defvector_init[3];
        double defvector_init_dvdx = defvector_init[4];
        double defvector_init_dvdy = defvector_init[5];
        defvector[0] = defvector_init_u - ((defvector_init_dudx + 1) * (gradient_buffer[0] + gradient_buffer[0] * gradient_buffer[5] - gradient_buffer[1] * gradient_buffer[3])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (defvector_init_dudy * (gradient_buffer[1] - gradient_buffer[0] * gradient_buffer[4] + gradient_buffer[1] * gradient_buffer[2])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1); // u
        defvector[1] = defvector_init_v - ((defvector_init_dvdy + 1) * (gradient_buffer[1] - gradient_buffer[0] * gradient_buffer[4] + gradient_buffer[1] * gradient_buffer[2])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (defvector_init_dvdx * (gradient_buffer[0] + gradient_buffer[0] * gradient_buffer[5] - gradient_buffer[1] * gradient_buffer[3])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1); // v
        defvector[2] = ((gradient_buffer[5] + 1) * (defvector_init_dudx + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[4] * defvector_init_dudy) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - 1;                                                                                                                                                                                      // du/dx
        defvector[3] = (defvector_init_dudy * (gradient_buffer[2] + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[3] * (defvector_init_dudx + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1);                                                                                                                                                                                          // du/dy
        defvector[4] = (defvector_init_dvdx * (gradient_buffer[5] + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[4] * (defvector_init_dvdy + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1);                                                                                                                                                                                          // dv/dx
        defvector[5] = ((gradient_buffer[2] + 1) * (defvector_init_dvdy + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[3] * defvector_init_dvdx) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - 1;                                                                                                                                                                                      // dv/dy

        // Return successful
        return true;
    }
    // Deltag was close to zero - return failed
    return false;
}

void Dic::matchSeed(std::size_t currentIndex) {
    double maxCorrelation = 0.0, correlation;
    std::pair<int, int> match, candidate;
    std::vector<double> serialSeed =
        serializeSubset(rimg, params.seedPoint);
    for (int i = 0; i < cimgs[currentIndex].gs.height; i++) {
        for (int j = 0; j < cimgs[currentIndex].gs.width; j++) {
            candidate = std::make_pair(i, j);
            correlation = dicutils::ncc(
                serialSeed, serializeSubset(cimgs[currentIndex], candidate));
            if (correlation > maxCorrelation) {
                match = candidate;
                maxCorrelation = correlation;
            }
        }
    }
    /*qDebug() << QString("for %1 th current image, found match at {%2, %3} with "
                        "correlation = %4")
                    .arg(currentIndex)
                    .arg(match.first)
                    .arg(match.second)
                    .arg(maxCorrelation);*/
}

std::vector<double> Dic::serializeSubset(class_img &image,
                                         std::pair<int, int> center) {
    unsigned long xMin = 0;
    unsigned long xMax = static_cast<unsigned long>(image.gs.width) - 1;
    unsigned long yMin = 0;
    unsigned long yMax = static_cast<unsigned long>(image.gs.height) - 1;
    unsigned long side = static_cast<unsigned long>(params.subsetSize);
    unsigned long xStart = static_cast<unsigned long>(center.first) - side / 2;
    unsigned long yStart = static_cast<unsigned long>(center.second) - side / 2;
    unsigned long x;
    unsigned long y;
    std::vector<double> res(static_cast<size_t>(side * side), 0.0);

    if (xStart < xMin or yStart < yMin or xStart + side - 1 > xMax or
        yStart + side - 1 > yMax) {
        std::vector<double> empty;
        return empty;
    }
    x = xStart;
    /*for (size_t i = 0; i < side; i++, x++) {
        y = yStart;
        for (size_t j = 0; j < side; j++, y++) {
            res[i * side + j] = static_cast<double>(image.getValue(static_cast<int>(x), static_cast<int>(y)));
        }
    }*/
    return res;
}

#include "dic.h"
#include "dicimage.h"
#include <QString>

Dic::Dic() {}

Dic::~Dic() {
    cimgs.clear();
    df_dx_buffer.clear();
    df_dy_buffer.clear();
    df_dp_buffer.clear();

    g_buffer.clear();
    x_vec_buffer.clear();
    y_vec_buffer.clear();
    gradient_buffer.clear();
    hessian_gn_buffer.clear();
    QK_B_QKT_buffer.clear();

    for (std::size_t i = 0; i < cimgs.size(); i++) {
        plot_u[i].free();
        plot_v[i].free();
        plot_corrcoef[i].free();
    }
    plot_calcpoints.reset();
}

void Dic::performDicAnalysis() {
    std::ofstream of("./dic_analysis.txt");
    double start = clock();

    int height = rimg.gs.height;
    int width = rimg.gs.width;

    oHeight = static_cast<int>(ceil(static_cast<double>(rimg.gs.height) / static_cast<double>(params.subsetSpacing + 1)));
    oWidth = static_cast<int>(ceil(static_cast<double>(rimg.gs.width) / static_cast<double>(params.subsetSpacing + 1)));

    //    of << "oHeight = " << oHeight << ", oWidth = " << oWidth << "\n";

    df_dx_buffer.resize(static_cast<unsigned long int>(height * width), 0.0);
    df_dy_buffer.resize(static_cast<unsigned long int>(height * width), 0.0);

    int radius = params.subsetSize;
    //    of << "Subset radius set at " << radius << "\n";

    //    of << "Resizing buffers\n";
    plot_calcpoints.alloc(oHeight, oWidth);
    g_buffer.resize((radius * 2 + 1) * (radius * 2 + 1), 0.0);
    df_dp_buffer.resize((radius * 2 + 1) * (radius * 2 + 1) * 6, 0.0);
    x_vec_buffer.resize(6, 0.0);
    y_vec_buffer.resize(6, 0.0);
    gradient_buffer.resize(6, 0.0);
    hessian_gn_buffer.resize(36, 0.0);
    QK_B_QKT_buffer.resize(36 * (rimg.bcoef.height - 5) * (rimg.bcoef.width - 5), 0.0);

    for (std::size_t i = 0; i < cimgs.size(); i++) {
        class_double_array plotu;
        class_double_array plotv;
        class_double_array plotcc;
        class_logical_array plotvp;

        plotu.alloc(oHeight, oWidth);
        plotv.alloc(oHeight, oWidth);
        plotcc.alloc(oHeight, oWidth);
        plotvp.alloc(oHeight, oWidth);

        plot_u.push_back(plotu);
        plot_v.push_back(plotv);
        plot_corrcoef.push_back(plotcc);
        plot_validpoints.push_back(plotvp);
    }
    //    of << "Pre compute reference image gradient\n";
    for (int i = rimg.border_bcoef - 2; i < rimg.border_bcoef + rimg.gs.width - 2; i++) {
        for (int j = rimg.border_bcoef - 2; j < rimg.border_bcoef + rimg.gs.height - 2; j++) {
            // Get bspline coefficients
            double b0 = rimg.bcoef.value[(j) + (i)*rimg.bcoef.height];
            double b1 = rimg.bcoef.value[(j + 1) + (i)*rimg.bcoef.height];
            double b2 = rimg.bcoef.value[(j + 2) + (i)*rimg.bcoef.height];
            double b3 = rimg.bcoef.value[(j + 3) + (i)*rimg.bcoef.height];
            double b4 = rimg.bcoef.value[(j + 4) + (i)*rimg.bcoef.height];
            double b6 = rimg.bcoef.value[(j) + (i + 1) * rimg.bcoef.height];
            double b7 = rimg.bcoef.value[(j + 1) + (i + 1) * rimg.bcoef.height];
            double b8 = rimg.bcoef.value[(j + 2) + (i + 1) * rimg.bcoef.height];
            double b9 = rimg.bcoef.value[(j + 3) + (i + 1) * rimg.bcoef.height];
            double b10 = rimg.bcoef.value[(j + 5) + (i + 1) * rimg.bcoef.height];
            double b12 = rimg.bcoef.value[(j) + (i + 2) * rimg.bcoef.height];
            double b13 = rimg.bcoef.value[(j + 1) + (i + 2) * rimg.bcoef.height];
            double b15 = rimg.bcoef.value[(j + 3) + (i + 2) * rimg.bcoef.height];
            double b16 = rimg.bcoef.value[(j + 4) + (i + 2) * rimg.bcoef.height];
            double b18 = rimg.bcoef.value[(j) + (i + 3) * rimg.bcoef.height];
            double b19 = rimg.bcoef.value[(j + 1) + (i + 3) * rimg.bcoef.height];
            double b20 = rimg.bcoef.value[(j + 2) + (i + 3) * rimg.bcoef.height];
            double b21 = rimg.bcoef.value[(j + 3) + (i + 3) * rimg.bcoef.height];
            double b22 = rimg.bcoef.value[(j + 4) + (i + 3) * rimg.bcoef.height];
            double b24 = rimg.bcoef.value[(j) + (i + 4) * rimg.bcoef.height];
            double b25 = rimg.bcoef.value[(j + 1) + (i + 4) * rimg.bcoef.height];
            double b26 = rimg.bcoef.value[(j + 2) + (i + 4) * rimg.bcoef.height];
            double b27 = rimg.bcoef.value[(j + 3) + (i + 4) * rimg.bcoef.height];
            double b28 = rimg.bcoef.value[(j + 4) + (i + 4) * rimg.bcoef.height];

            // Compute base index
            std::size_t lind_f = (j - (rimg.border_bcoef - 2)) + (i - (rimg.border_bcoef - 2)) * rimg.gs.height;

            // Compute Gradients using b-spline coefficients
            // First order
            df_dx_buffer[lind_f] = 0.003472222222222222 * b18 - 0.009027777777777778 * b1 - 0.003472222222222222 * b10 - 0.0003472222222222222 * b0 + 0.09027777777777778 * b19 - 0.02291666666666667 * b2 + 0.2291666666666667 * b20 + 0.09027777777777778 * b21 + 0.003472222222222222 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 - 0.009027777777777778 * b3 - 0.0003472222222222222 * b4 - 0.003472222222222222 * b6 - 0.09027777777777778 * b7 - 0.2291666666666667 * b8 - 0.09027777777777778 * b9;
            df_dy_buffer[lind_f] = 0.009027777777777778 * b10 - 0.003472222222222222 * b1 - 0.0003472222222222222 * b0 - 0.02291666666666667 * b12 - 0.2291666666666667 * b13 + 0.2291666666666667 * b15 + 0.02291666666666667 * b16 - 0.009027777777777778 * b18 - 0.09027777777777778 * b19 + 0.09027777777777778 * b21 + 0.009027777777777778 * b22 - 0.0003472222222222222 * b24 - 0.003472222222222222 * b25 + 0.003472222222222222 * b27 + 0.0003472222222222222 * b28 + 0.003472222222222222 * b3 + 0.0003472222222222222 * b4 - 0.009027777777777778 * b6 - 0.09027777777777778 * b7 + 0.09027777777777778 * b9;
        }
    }

    //-----hardcoded
    {
        std::vector<double> s;
        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.095840425430045839139125973816);
        s.push_back(-0.732317866870052736061325049377);
        s.push_back(0.001821096044614556319629627978);
        s.push_back(-0.000545352506291277706711173590);
        s.push_back(-0.000427246325667928763224201472);
        s.push_back(-0.000202669893530904587919394544);
        s.push_back(0.004202853127554376233554478404);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.167313908224413387948459330801);
        s.push_back(-1.588064705986378166713279824762);
        s.push_back(0.000609349652546109510353744554);
        s.push_back(-0.001416492698193724721761332930);
        s.push_back(-0.001369838131914909292938253849);
        s.push_back(0.001396967298978202265402615012);
        s.push_back(0.005187581801706664733075946572);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.297625267818690641963286225291);
        s.push_back(-2.597216378481681964274230267620);
        s.push_back(0.000835659166694702193467492179);
        s.push_back(-0.000897108980918165680937259587);
        s.push_back(-0.001441745481586308944704777346);
        s.push_back(0.000790569004959884580330253812);
        s.push_back(0.005965394530639114845094184147);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.427383275303523990640286456255);
        s.push_back(-3.546009782202506066539626772283);
        s.push_back(0.000745481215133292351993077318);
        s.push_back(0.000361092071449245206708755784);
        s.push_back(-0.001402544529483555450777299001);
        s.push_back(0.002448386062763763248995019239);
        s.push_back(0.005392031209876273732672924410);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.512351662610064484404404083762);
        s.push_back(-4.574333149973885070949108921923);
        s.push_back(0.001223823979220606261719694885);
        s.push_back(0.000190720397147182616198052285);
        s.push_back(-0.001459134387936082948716842722);
        s.push_back(0.002653694524215932659672034788);
        s.push_back(0.005608445252079081663754145382);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.540872588977671764354226979776);
        s.push_back(-5.582713974833469094960491929669);
        s.push_back(0.001202174129782296319035594934);
        s.push_back(0.000677181857243697583707831011);
        s.push_back(-0.002050107516048345780018680173);
        s.push_back(0.002423010817783621817511630070);
        s.push_back(0.005607845557184478434142871350);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.596369490414699332525572117447);
        s.push_back(-6.650732552052091683947310229996);
        s.push_back(-0.000180296048918671125704804581);
        s.push_back(-0.000073029704477226332101462425);
        s.push_back(-0.001711469228851091256907168692);
        s.push_back(0.002155436157423196164018008858);
        s.push_back(0.005679640573269848814741411758);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.663880440211723210630623270845);
        s.push_back(-7.803851550874771447752209496684);
        s.push_back(0.001810348482710555373387251166);
        s.push_back(0.000762743938499883247436605949);
        s.push_back(-0.000917562930250373823791443240);
        s.push_back(0.004300692980042652990846363537);
        s.push_back(0.005145314047186329287075778893);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.717766282438922487152410667477);
        s.push_back(-8.993500643510536463054449995980);
        s.push_back(0.000273138485438417788486731297);
        s.push_back(0.000994990661155167573428959038);
        s.push_back(-0.000914095651979697628938814624);
        s.push_back(0.003550113402470689294432304450);
        s.push_back(0.004564473308980217594599260167);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.887632805087676279853781124984);
        s.push_back(-10.228279723433015391265143989585);
        s.push_back(-0.001147584921972311100546448870);
        s.push_back(-0.000131280343749426984308742439);
        s.push_back(-0.003427160335113154081970732179);
        s.push_back(0.004407954973728811509658953582);
        s.push_back(0.004632741646495763289392844086);
        seed_info.push_back(s);
        s.clear();

        s.push_back(187.000000000000000000000000000000);
        s.push_back(330.000000000000000000000000000000);
        s.push_back(-0.851161352505980350890979480027);
        s.push_back(-10.318876002816340431422759138513);
        s.push_back(-0.000476687102692108233270573692);
        s.push_back(0.000434197214999161530592924896);
        s.push_back(-0.000857015047537299868088411792);
        s.push_back(0.005297081460698738197834245511);
        s.push_back(0.004557846047304266352828694409);
        seed_info.push_back(s);
        s.clear();


    }
    //
    double overhead = clock() - start;
    overhead /= CLOCKS_PER_SEC;
    //of << "Overhead time was " << overhead << "\n";
    // Dic for each current image
    for (std::size_t i = 0; i < cimgs.size(); i++) {
        //        of << "Start dic for current image #" << i << "--------------------------------------------------------------\n";
        //        of << "Precompute for g(" << i << ")\n";
        double yime = clock();
        preCompute(of, i);
        //        of << "Precompute took " << ((clock() - yime) / CLOCKS_PER_SEC) << "s\n";
        // matchSeed(i);

        //        of << "Setting roi cirroi\n";
        roi.set_cirroi(radius);
        analysis(of, i);
        plot_calcpoints.reset();
        //of << ((clock() - yime) / CLOCKS_PER_SEC) << "\n";
    }
    std::ofstream file("plots");
    for (int i = 0; i < cimgs.size(); i++) {
        file << "Analysis over! Printing plotu/plotv/plotcorr for first curr image only\n\n";
        for (int r = 0; r < plot_u[i].height; r++) {
            for (int c = 0; c < plot_u[i].width; c++) {
                file << plot_u[i].value[r + c * plot_u[i].height] << " ";
            }
            file << "\n";
        }
        file << "\n";
        for (int r = 0; r < plot_v[i].height; r++) {
            for (int c = 0; c < plot_v[i].width; c++) {
                file << plot_v[i].value[r + c * plot_v[i].height] << " ";
            }
            file << "\n";
        }
        file << "\n";
        for (int r = 0; r < plot_corrcoef[i].height; r++) {
            for (int c = 0; c < plot_corrcoef[i].width; c++) {
                file << plot_corrcoef[i].value[r + c * plot_corrcoef[i].height] << " ";
            }
            file << "\n";
        }
        file << "\n";
    }
    file.close();
    of.close();
}

void Dic::preCompute(std::ofstream &of, std::size_t currImg) {
    // Pre compute interpolation coefficients ---------------------------//
    int height = cimgs[currImg].bcoef.height;
    for (int i = 0; i < cimgs[currImg].bcoef.width - 5; i++) {
        for (int j = 0; j < height - 5; j++) {
            // Get bspline coefficients
            double b0 = cimgs[currImg].bcoef.value[(j) + (i)*height];
            double b1 = cimgs[currImg].bcoef.value[(j + 1) + (i)*height];
            double b2 = cimgs[currImg].bcoef.value[(j + 2) + (i)*height];
            double b3 = cimgs[currImg].bcoef.value[(j + 3) + (i)*height];
            double b4 = cimgs[currImg].bcoef.value[(j + 4) + (i)*height];
            double b5 = cimgs[currImg].bcoef.value[(j + 5) + (i)*height];
            double b6 = cimgs[currImg].bcoef.value[(j) + (i + 1) * height];
            double b7 = cimgs[currImg].bcoef.value[(j + 1) + (i + 1) * height];
            double b8 = cimgs[currImg].bcoef.value[(j + 2) + (i + 1) * height];
            double b9 = cimgs[currImg].bcoef.value[(j + 3) + (i + 1) * height];
            double b10 = cimgs[currImg].bcoef.value[(j + 4) + (i + 1) * height];
            double b11 = cimgs[currImg].bcoef.value[(j + 5) + (i + 1) * height];
            double b12 = cimgs[currImg].bcoef.value[(j) + (i + 2) * height];
            double b13 = cimgs[currImg].bcoef.value[(j + 1) + (i + 2) * height];
            double b14 = cimgs[currImg].bcoef.value[(j + 2) + (i + 2) * height];
            double b15 = cimgs[currImg].bcoef.value[(j + 3) + (i + 2) * height];
            double b16 = cimgs[currImg].bcoef.value[(j + 4) + (i + 2) * height];
            double b17 = cimgs[currImg].bcoef.value[(j + 5) + (i + 2) * height];
            double b18 = cimgs[currImg].bcoef.value[(j) + (i + 3) * height];
            double b19 = cimgs[currImg].bcoef.value[(j + 1) + (i + 3) * height];
            double b20 = cimgs[currImg].bcoef.value[(j + 2) + (i + 3) * height];
            double b21 = cimgs[currImg].bcoef.value[(j + 3) + (i + 3) * height];
            double b22 = cimgs[currImg].bcoef.value[(j + 4) + (i + 3) * height];
            double b23 = cimgs[currImg].bcoef.value[(j + 5) + (i + 3) * height];
            double b24 = cimgs[currImg].bcoef.value[(j) + (i + 4) * height];
            double b25 = cimgs[currImg].bcoef.value[(j + 1) + (i + 4) * height];
            double b26 = cimgs[currImg].bcoef.value[(j + 2) + (i + 4) * height];
            double b27 = cimgs[currImg].bcoef.value[(j + 3) + (i + 4) * height];
            double b28 = cimgs[currImg].bcoef.value[(j + 4) + (i + 4) * height];
            double b29 = cimgs[currImg].bcoef.value[(j + 5) + (i + 4) * height];
            double b30 = cimgs[currImg].bcoef.value[(j) + (i + 5) * height];
            double b31 = cimgs[currImg].bcoef.value[(j + 1) + (i + 5) * height];
            double b32 = cimgs[currImg].bcoef.value[(j + 2) + (i + 5) * height];
            double b33 = cimgs[currImg].bcoef.value[(j + 3) + (i + 5) * height];
            double b34 = cimgs[currImg].bcoef.value[(j + 4) + (i + 5) * height];
            double b35 = cimgs[currImg].bcoef.value[(j + 5) + (i + 5) * height];

            //Compute base index
            int lind_qkbqkt = j * (36) + i * (36 * (height - 5));

            //Compute QK_B_QKT vector
            QK_B_QKT_buffer[lind_qkbqkt] = 0.00006944444444444444 * b0 + 0.001805555555555556 * b1 + 0.001805555555555556 * b10 + 0.004583333333333333 * b12 + 0.1191666666666667 * b13 + 0.3025 * b14 + 0.1191666666666667 * b15 + 0.004583333333333333 * b16 + 0.001805555555555556 * b18 + 0.04694444444444444 * b19 + 0.004583333333333333 * b2 + 0.1191666666666667 * b20 + 0.04694444444444444 * b21 + 0.001805555555555556 * b22 + 0.00006944444444444444 * b24 + 0.001805555555555556 * b25 + 0.004583333333333333 * b26 + 0.001805555555555556 * b27 + 0.00006944444444444444 * b28 + 0.001805555555555556 * b3 + 0.00006944444444444444 * b4 + 0.001805555555555556 * b6 + 0.04694444444444444 * b7 + 0.1191666666666667 * b8 + 0.04694444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 1] = 0.009027777777777778 * b10 - 0.003472222222222222 * b1 - 0.0003472222222222222 * b0 - 0.02291666666666667 * b12 - 0.2291666666666667 * b13 + 0.2291666666666667 * b15 + 0.02291666666666667 * b16 - 0.009027777777777778 * b18 - 0.09027777777777778 * b19 + 0.09027777777777778 * b21 + 0.009027777777777778 * b22 - 0.0003472222222222222 * b24 - 0.003472222222222222 * b25 + 0.003472222222222222 * b27 + 0.0003472222222222222 * b28 + 0.003472222222222222 * b3 + 0.0003472222222222222 * b4 - 0.009027777777777778 * b6 - 0.09027777777777778 * b7 + 0.09027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 2] = 0.0006944444444444444 * b0 + 0.001388888888888889 * b1 + 0.01805555555555556 * b10 + 0.04583333333333333 * b12 + 0.09166666666666667 * b13 - 0.275 * b14 + 0.09166666666666667 * b15 + 0.04583333333333333 * b16 + 0.01805555555555556 * b18 + 0.03611111111111111 * b19 - 0.004166666666666667 * b2 - 0.1083333333333333 * b20 + 0.03611111111111111 * b21 + 0.01805555555555556 * b22 + 0.0006944444444444444 * b24 + 0.001388888888888889 * b25 - 0.004166666666666667 * b26 + 0.001388888888888889 * b27 + 0.0006944444444444444 * b28 + 0.001388888888888889 * b3 + 0.0006944444444444444 * b4 + 0.01805555555555556 * b6 + 0.03611111111111111 * b7 - 0.1083333333333333 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 3] = 0.001388888888888889 * b1 - 0.0006944444444444444 * b0 + 0.01805555555555556 * b10 - 0.04583333333333333 * b12 + 0.09166666666666667 * b13 - 0.09166666666666667 * b15 + 0.04583333333333333 * b16 - 0.01805555555555556 * b18 + 0.03611111111111111 * b19 - 0.03611111111111111 * b21 + 0.01805555555555556 * b22 - 0.0006944444444444444 * b24 + 0.001388888888888889 * b25 - 0.001388888888888889 * b27 + 0.0006944444444444444 * b28 - 0.001388888888888889 * b3 + 0.0006944444444444444 * b4 - 0.01805555555555556 * b6 + 0.03611111111111111 * b7 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 4] = 0.0003472222222222222 * b0 - 0.001388888888888889 * b1 + 0.009027777777777778 * b10 + 0.02291666666666667 * b12 - 0.09166666666666667 * b13 + 0.1375 * b14 - 0.09166666666666667 * b15 + 0.02291666666666667 * b16 + 0.009027777777777778 * b18 - 0.03611111111111111 * b19 + 0.002083333333333333 * b2 + 0.05416666666666667 * b20 - 0.03611111111111111 * b21 + 0.009027777777777778 * b22 + 0.0003472222222222222 * b24 - 0.001388888888888889 * b25 + 0.002083333333333333 * b26 - 0.001388888888888889 * b27 + 0.0003472222222222222 * b28 - 0.001388888888888889 * b3 + 0.0003472222222222222 * b4 + 0.009027777777777778 * b6 - 0.03611111111111111 * b7 + 0.05416666666666667 * b8 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 5] = 0.0003472222222222222 * b1 - 0.00006944444444444444 * b0 - 0.009027777777777778 * b10 + 0.001805555555555556 * b11 - 0.004583333333333333 * b12 + 0.02291666666666667 * b13 - 0.04583333333333333 * b14 + 0.04583333333333333 * b15 - 0.02291666666666667 * b16 + 0.004583333333333333 * b17 - 0.001805555555555556 * b18 + 0.009027777777777778 * b19 - 0.0006944444444444444 * b2 - 0.01805555555555556 * b20 + 0.01805555555555556 * b21 - 0.009027777777777778 * b22 + 0.001805555555555556 * b23 - 0.00006944444444444444 * b24 + 0.0003472222222222222 * b25 - 0.0006944444444444444 * b26 + 0.0006944444444444444 * b27 - 0.0003472222222222222 * b28 + 0.00006944444444444444 * b29 + 0.0006944444444444444 * b3 - 0.0003472222222222222 * b4 + 0.00006944444444444444 * b5 - 0.001805555555555556 * b6 + 0.009027777777777778 * b7 - 0.01805555555555556 * b8 + 0.01805555555555556 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 6] = 0.003472222222222222 * b18 - 0.009027777777777778 * b1 - 0.003472222222222222 * b10 - 0.0003472222222222222 * b0 + 0.09027777777777778 * b19 - 0.02291666666666667 * b2 + 0.2291666666666667 * b20 + 0.09027777777777778 * b21 + 0.003472222222222222 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 - 0.009027777777777778 * b3 - 0.0003472222222222222 * b4 - 0.003472222222222222 * b6 - 0.09027777777777778 * b7 - 0.2291666666666667 * b8 - 0.09027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 7] = 0.001736111111111111 * b0 + 0.01736111111111111 * b1 - 0.01736111111111111 * b10 - 0.01736111111111111 * b18 - 0.1736111111111111 * b19 + 0.1736111111111111 * b21 + 0.01736111111111111 * b22 - 0.001736111111111111 * b24 - 0.01736111111111111 * b25 + 0.01736111111111111 * b27 + 0.001736111111111111 * b28 - 0.01736111111111111 * b3 - 0.001736111111111111 * b4 + 0.01736111111111111 * b6 + 0.1736111111111111 * b7 - 0.1736111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 8] = 0.03472222222222222 * b18 - 0.006944444444444444 * b1 - 0.03472222222222222 * b10 - 0.003472222222222222 * b0 + 0.06944444444444444 * b19 + 0.02083333333333333 * b2 - 0.2083333333333333 * b20 + 0.06944444444444444 * b21 + 0.03472222222222222 * b22 + 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.02083333333333333 * b26 + 0.006944444444444444 * b27 + 0.003472222222222222 * b28 - 0.006944444444444444 * b3 - 0.003472222222222222 * b4 - 0.03472222222222222 * b6 - 0.06944444444444444 * b7 + 0.2083333333333333 * b8 - 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 9] = 0.003472222222222222 * b0 - 0.006944444444444444 * b1 - 0.03472222222222222 * b10 - 0.03472222222222222 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 + 0.03472222222222222 * b22 - 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.006944444444444444 * b27 + 0.003472222222222222 * b28 + 0.006944444444444444 * b3 - 0.003472222222222222 * b4 + 0.03472222222222222 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 10] = 0.006944444444444444 * b1 - 0.001736111111111111 * b0 - 0.01736111111111111 * b10 + 0.01736111111111111 * b18 - 0.06944444444444444 * b19 - 0.01041666666666667 * b2 + 0.1041666666666667 * b20 - 0.06944444444444444 * b21 + 0.01736111111111111 * b22 + 0.001736111111111111 * b24 - 0.006944444444444444 * b25 + 0.01041666666666667 * b26 - 0.006944444444444444 * b27 + 0.001736111111111111 * b28 + 0.006944444444444444 * b3 - 0.001736111111111111 * b4 - 0.01736111111111111 * b6 + 0.06944444444444444 * b7 - 0.1041666666666667 * b8 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 11] = 0.0003472222222222222 * b0 - 0.001736111111111111 * b1 + 0.01736111111111111 * b10 - 0.003472222222222222 * b11 - 0.003472222222222222 * b18 + 0.01736111111111111 * b19 + 0.003472222222222222 * b2 - 0.03472222222222222 * b20 + 0.03472222222222222 * b21 - 0.01736111111111111 * b22 + 0.003472222222222222 * b23 - 0.0003472222222222222 * b24 + 0.001736111111111111 * b25 - 0.003472222222222222 * b26 + 0.003472222222222222 * b27 - 0.001736111111111111 * b28 + 0.0003472222222222222 * b29 - 0.003472222222222222 * b3 + 0.001736111111111111 * b4 - 0.0003472222222222222 * b5 + 0.003472222222222222 * b6 - 0.01736111111111111 * b7 + 0.03472222222222222 * b8 - 0.03472222222222222 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 12] = 0.0006944444444444444 * b0 + 0.01805555555555556 * b1 + 0.001388888888888889 * b10 - 0.004166666666666667 * b12 - 0.1083333333333333 * b13 - 0.275 * b14 - 0.1083333333333333 * b15 - 0.004166666666666667 * b16 + 0.001388888888888889 * b18 + 0.03611111111111111 * b19 + 0.04583333333333333 * b2 + 0.09166666666666667 * b20 + 0.03611111111111111 * b21 + 0.001388888888888889 * b22 + 0.0006944444444444444 * b24 + 0.01805555555555556 * b25 + 0.04583333333333333 * b26 + 0.01805555555555556 * b27 + 0.0006944444444444444 * b28 + 0.01805555555555556 * b3 + 0.0006944444444444444 * b4 + 0.001388888888888889 * b6 + 0.03611111111111111 * b7 + 0.09166666666666667 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 13] = 0.006944444444444444 * b10 - 0.03472222222222222 * b1 - 0.003472222222222222 * b0 + 0.02083333333333333 * b12 + 0.2083333333333333 * b13 - 0.2083333333333333 * b15 - 0.02083333333333333 * b16 - 0.006944444444444444 * b18 - 0.06944444444444444 * b19 + 0.06944444444444444 * b21 + 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.03472222222222222 * b25 + 0.03472222222222222 * b27 + 0.003472222222222222 * b28 + 0.03472222222222222 * b3 + 0.003472222222222222 * b4 - 0.006944444444444444 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 14] = 0.006944444444444444 * b0 + 0.01388888888888889 * b1 + 0.01388888888888889 * b10 - 0.04166666666666667 * b12 - 0.08333333333333333 * b13 + 0.25 * b14 - 0.08333333333333333 * b15 - 0.04166666666666667 * b16 + 0.01388888888888889 * b18 + 0.02777777777777778 * b19 - 0.04166666666666667 * b2 - 0.08333333333333333 * b20 + 0.02777777777777778 * b21 + 0.01388888888888889 * b22 + 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.04166666666666667 * b26 + 0.01388888888888889 * b27 + 0.006944444444444444 * b28 + 0.01388888888888889 * b3 + 0.006944444444444444 * b4 + 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.08333333333333333 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 15] = 0.01388888888888889 * b1 - 0.006944444444444444 * b0 + 0.01388888888888889 * b10 + 0.04166666666666667 * b12 - 0.08333333333333333 * b13 + 0.08333333333333333 * b15 - 0.04166666666666667 * b16 - 0.01388888888888889 * b18 + 0.02777777777777778 * b19 - 0.02777777777777778 * b21 + 0.01388888888888889 * b22 - 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.01388888888888889 * b27 + 0.006944444444444444 * b28 - 0.01388888888888889 * b3 + 0.006944444444444444 * b4 - 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 16] = 0.003472222222222222 * b0 - 0.01388888888888889 * b1 + 0.006944444444444444 * b10 - 0.02083333333333333 * b12 + 0.08333333333333333 * b13 - 0.125 * b14 + 0.08333333333333333 * b15 - 0.02083333333333333 * b16 + 0.006944444444444444 * b18 - 0.02777777777777778 * b19 + 0.02083333333333333 * b2 + 0.04166666666666667 * b20 - 0.02777777777777778 * b21 + 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.01388888888888889 * b25 + 0.02083333333333333 * b26 - 0.01388888888888889 * b27 + 0.003472222222222222 * b28 - 0.01388888888888889 * b3 + 0.003472222222222222 * b4 + 0.006944444444444444 * b6 - 0.02777777777777778 * b7 + 0.04166666666666667 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 17] = 0.003472222222222222 * b1 - 0.0006944444444444444 * b0 - 0.006944444444444444 * b10 + 0.001388888888888889 * b11 + 0.004166666666666667 * b12 - 0.02083333333333333 * b13 + 0.04166666666666667 * b14 - 0.04166666666666667 * b15 + 0.02083333333333333 * b16 - 0.004166666666666667 * b17 - 0.001388888888888889 * b18 + 0.006944444444444444 * b19 - 0.006944444444444444 * b2 - 0.01388888888888889 * b20 + 0.01388888888888889 * b21 - 0.006944444444444444 * b22 + 0.001388888888888889 * b23 - 0.0006944444444444444 * b24 + 0.003472222222222222 * b25 - 0.006944444444444444 * b26 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.0006944444444444444 * b29 + 0.006944444444444444 * b3 - 0.003472222222222222 * b4 + 0.0006944444444444444 * b5 - 0.001388888888888889 * b6 + 0.006944444444444444 * b7 - 0.01388888888888889 * b8 + 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 18] = 0.001388888888888889 * b10 - 0.01805555555555556 * b1 - 0.0006944444444444444 * b0 - 0.001388888888888889 * b18 - 0.03611111111111111 * b19 - 0.04583333333333333 * b2 - 0.09166666666666667 * b20 - 0.03611111111111111 * b21 - 0.001388888888888889 * b22 + 0.0006944444444444444 * b24 + 0.01805555555555556 * b25 + 0.04583333333333333 * b26 + 0.01805555555555556 * b27 + 0.0006944444444444444 * b28 - 0.01805555555555556 * b3 - 0.0006944444444444444 * b4 + 0.001388888888888889 * b6 + 0.03611111111111111 * b7 + 0.09166666666666667 * b8 + 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 19] = 0.003472222222222222 * b0 + 0.03472222222222222 * b1 + 0.006944444444444444 * b10 + 0.006944444444444444 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 - 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.03472222222222222 * b25 + 0.03472222222222222 * b27 + 0.003472222222222222 * b28 - 0.03472222222222222 * b3 - 0.003472222222222222 * b4 - 0.006944444444444444 * b6 - 0.06944444444444444 * b7 + 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 20] = 0.01388888888888889 * b10 - 0.01388888888888889 * b1 - 0.006944444444444444 * b0 - 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.04166666666666667 * b2 + 0.08333333333333333 * b20 - 0.02777777777777778 * b21 - 0.01388888888888889 * b22 + 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.04166666666666667 * b26 + 0.01388888888888889 * b27 + 0.006944444444444444 * b28 - 0.01388888888888889 * b3 - 0.006944444444444444 * b4 + 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.08333333333333333 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 21] = 0.006944444444444444 * b0 - 0.01388888888888889 * b1 + 0.01388888888888889 * b10 + 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.02777777777777778 * b21 - 0.01388888888888889 * b22 - 0.006944444444444444 * b24 + 0.01388888888888889 * b25 - 0.01388888888888889 * b27 + 0.006944444444444444 * b28 + 0.01388888888888889 * b3 - 0.006944444444444444 * b4 - 0.01388888888888889 * b6 + 0.02777777777777778 * b7 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 22] = 0.01388888888888889 * b1 - 0.003472222222222222 * b0 + 0.006944444444444444 * b10 - 0.006944444444444444 * b18 + 0.02777777777777778 * b19 - 0.02083333333333333 * b2 - 0.04166666666666667 * b20 + 0.02777777777777778 * b21 - 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.01388888888888889 * b25 + 0.02083333333333333 * b26 - 0.01388888888888889 * b27 + 0.003472222222222222 * b28 + 0.01388888888888889 * b3 - 0.003472222222222222 * b4 + 0.006944444444444444 * b6 - 0.02777777777777778 * b7 + 0.04166666666666667 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 23] = 0.0006944444444444444 * b0 - 0.003472222222222222 * b1 - 0.006944444444444444 * b10 + 0.001388888888888889 * b11 + 0.001388888888888889 * b18 - 0.006944444444444444 * b19 + 0.006944444444444444 * b2 + 0.01388888888888889 * b20 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.001388888888888889 * b23 - 0.0006944444444444444 * b24 + 0.003472222222222222 * b25 - 0.006944444444444444 * b26 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.0006944444444444444 * b29 - 0.006944444444444444 * b3 + 0.003472222222222222 * b4 - 0.0006944444444444444 * b5 - 0.001388888888888889 * b6 + 0.006944444444444444 * b7 - 0.01388888888888889 * b8 + 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 24] = 0.0003472222222222222 * b0 + 0.009027777777777778 * b1 - 0.001388888888888889 * b10 + 0.002083333333333333 * b12 + 0.05416666666666667 * b13 + 0.1375 * b14 + 0.05416666666666667 * b15 + 0.002083333333333333 * b16 - 0.001388888888888889 * b18 - 0.03611111111111111 * b19 + 0.02291666666666667 * b2 - 0.09166666666666667 * b20 - 0.03611111111111111 * b21 - 0.001388888888888889 * b22 + 0.0003472222222222222 * b24 + 0.009027777777777778 * b25 + 0.02291666666666667 * b26 + 0.009027777777777778 * b27 + 0.0003472222222222222 * b28 + 0.009027777777777778 * b3 + 0.0003472222222222222 * b4 - 0.001388888888888889 * b6 - 0.03611111111111111 * b7 - 0.09166666666666667 * b8 - 0.03611111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 25] = 0.1041666666666667 * b15 - 0.01736111111111111 * b1 - 0.006944444444444444 * b10 - 0.01041666666666667 * b12 - 0.1041666666666667 * b13 - 0.001736111111111111 * b0 + 0.01041666666666667 * b16 + 0.006944444444444444 * b18 + 0.06944444444444444 * b19 - 0.06944444444444444 * b21 - 0.006944444444444444 * b22 - 0.001736111111111111 * b24 - 0.01736111111111111 * b25 + 0.01736111111111111 * b27 + 0.001736111111111111 * b28 + 0.01736111111111111 * b3 + 0.001736111111111111 * b4 + 0.006944444444444444 * b6 + 0.06944444444444444 * b7 - 0.06944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 26] = 0.003472222222222222 * b0 + 0.006944444444444444 * b1 - 0.01388888888888889 * b10 + 0.02083333333333333 * b12 + 0.04166666666666667 * b13 - 0.125 * b14 + 0.04166666666666667 * b15 + 0.02083333333333333 * b16 - 0.01388888888888889 * b18 - 0.02777777777777778 * b19 - 0.02083333333333333 * b2 + 0.08333333333333333 * b20 - 0.02777777777777778 * b21 - 0.01388888888888889 * b22 + 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.02083333333333333 * b26 + 0.006944444444444444 * b27 + 0.003472222222222222 * b28 + 0.006944444444444444 * b3 + 0.003472222222222222 * b4 - 0.01388888888888889 * b6 - 0.02777777777777778 * b7 + 0.08333333333333333 * b8 - 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 27] = 0.006944444444444444 * b1 - 0.003472222222222222 * b0 - 0.01388888888888889 * b10 - 0.02083333333333333 * b12 + 0.04166666666666667 * b13 - 0.04166666666666667 * b15 + 0.02083333333333333 * b16 + 0.01388888888888889 * b18 - 0.02777777777777778 * b19 + 0.02777777777777778 * b21 - 0.01388888888888889 * b22 - 0.003472222222222222 * b24 + 0.006944444444444444 * b25 - 0.006944444444444444 * b27 + 0.003472222222222222 * b28 - 0.006944444444444444 * b3 + 0.003472222222222222 * b4 + 0.01388888888888889 * b6 - 0.02777777777777778 * b7 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 28] = 0.001736111111111111 * b0 - 0.006944444444444444 * b1 - 0.006944444444444444 * b10 + 0.01041666666666667 * b12 - 0.04166666666666667 * b13 + 0.0625 * b14 - 0.04166666666666667 * b15 + 0.01041666666666667 * b16 - 0.006944444444444444 * b18 + 0.02777777777777778 * b19 + 0.01041666666666667 * b2 - 0.04166666666666667 * b20 + 0.02777777777777778 * b21 - 0.006944444444444444 * b22 + 0.001736111111111111 * b24 - 0.006944444444444444 * b25 + 0.01041666666666667 * b26 - 0.006944444444444444 * b27 + 0.001736111111111111 * b28 - 0.006944444444444444 * b3 + 0.001736111111111111 * b4 - 0.006944444444444444 * b6 + 0.02777777777777778 * b7 - 0.04166666666666667 * b8 + 0.02777777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 29] = 0.001736111111111111 * b1 - 0.0003472222222222222 * b0 + 0.006944444444444444 * b10 - 0.001388888888888889 * b11 - 0.002083333333333333 * b12 + 0.01041666666666667 * b13 - 0.02083333333333333 * b14 + 0.02083333333333333 * b15 - 0.01041666666666667 * b16 + 0.002083333333333333 * b17 + 0.001388888888888889 * b18 - 0.006944444444444444 * b19 - 0.003472222222222222 * b2 + 0.01388888888888889 * b20 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.001388888888888889 * b23 - 0.0003472222222222222 * b24 + 0.001736111111111111 * b25 - 0.003472222222222222 * b26 + 0.003472222222222222 * b27 - 0.001736111111111111 * b28 + 0.0003472222222222222 * b29 + 0.003472222222222222 * b3 - 0.001736111111111111 * b4 + 0.0003472222222222222 * b5 + 0.001388888888888889 * b6 - 0.006944444444444444 * b7 + 0.01388888888888889 * b8 - 0.01388888888888889 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 30] = 0.0003472222222222222 * b10 - 0.001805555555555556 * b1 - 0.00006944444444444444 * b0 - 0.0006944444444444444 * b12 - 0.01805555555555556 * b13 - 0.04583333333333333 * b14 - 0.01805555555555556 * b15 - 0.0006944444444444444 * b16 + 0.0006944444444444444 * b18 + 0.01805555555555556 * b19 - 0.004583333333333333 * b2 + 0.04583333333333333 * b20 + 0.01805555555555556 * b21 + 0.0006944444444444444 * b22 - 0.0003472222222222222 * b24 - 0.009027777777777778 * b25 - 0.02291666666666667 * b26 - 0.009027777777777778 * b27 - 0.0003472222222222222 * b28 - 0.001805555555555556 * b3 + 0.00006944444444444444 * b30 + 0.001805555555555556 * b31 + 0.004583333333333333 * b32 + 0.001805555555555556 * b33 + 0.00006944444444444444 * b34 - 0.00006944444444444444 * b4 + 0.0003472222222222222 * b6 + 0.009027777777777778 * b7 + 0.02291666666666667 * b8 + 0.009027777777777778 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 31] = 0.0003472222222222222 * b0 + 0.003472222222222222 * b1 + 0.001736111111111111 * b10 + 0.003472222222222222 * b12 + 0.03472222222222222 * b13 - 0.03472222222222222 * b15 - 0.003472222222222222 * b16 - 0.003472222222222222 * b18 - 0.03472222222222222 * b19 + 0.03472222222222222 * b21 + 0.003472222222222222 * b22 + 0.001736111111111111 * b24 + 0.01736111111111111 * b25 - 0.01736111111111111 * b27 - 0.001736111111111111 * b28 - 0.003472222222222222 * b3 - 0.0003472222222222222 * b30 - 0.003472222222222222 * b31 + 0.003472222222222222 * b33 + 0.0003472222222222222 * b34 - 0.0003472222222222222 * b4 - 0.001736111111111111 * b6 - 0.01736111111111111 * b7 + 0.01736111111111111 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 32] = 0.003472222222222222 * b10 - 0.001388888888888889 * b1 - 0.0006944444444444444 * b0 - 0.006944444444444444 * b12 - 0.01388888888888889 * b13 + 0.04166666666666667 * b14 - 0.01388888888888889 * b15 - 0.006944444444444444 * b16 + 0.006944444444444444 * b18 + 0.01388888888888889 * b19 + 0.004166666666666667 * b2 - 0.04166666666666667 * b20 + 0.01388888888888889 * b21 + 0.006944444444444444 * b22 - 0.003472222222222222 * b24 - 0.006944444444444444 * b25 + 0.02083333333333333 * b26 - 0.006944444444444444 * b27 - 0.003472222222222222 * b28 - 0.001388888888888889 * b3 + 0.0006944444444444444 * b30 + 0.001388888888888889 * b31 - 0.004166666666666667 * b32 + 0.001388888888888889 * b33 + 0.0006944444444444444 * b34 - 0.0006944444444444444 * b4 + 0.003472222222222222 * b6 + 0.006944444444444444 * b7 - 0.02083333333333333 * b8 + 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 33] = 0.0006944444444444444 * b0 - 0.001388888888888889 * b1 + 0.003472222222222222 * b10 + 0.006944444444444444 * b12 - 0.01388888888888889 * b13 + 0.01388888888888889 * b15 - 0.006944444444444444 * b16 - 0.006944444444444444 * b18 + 0.01388888888888889 * b19 - 0.01388888888888889 * b21 + 0.006944444444444444 * b22 + 0.003472222222222222 * b24 - 0.006944444444444444 * b25 + 0.006944444444444444 * b27 - 0.003472222222222222 * b28 + 0.001388888888888889 * b3 - 0.0006944444444444444 * b30 + 0.001388888888888889 * b31 - 0.001388888888888889 * b33 + 0.0006944444444444444 * b34 - 0.0006944444444444444 * b4 - 0.003472222222222222 * b6 + 0.006944444444444444 * b7 - 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 34] = 0.001388888888888889 * b1 - 0.0003472222222222222 * b0 + 0.001736111111111111 * b10 - 0.003472222222222222 * b12 + 0.01388888888888889 * b13 - 0.02083333333333333 * b14 + 0.01388888888888889 * b15 - 0.003472222222222222 * b16 + 0.003472222222222222 * b18 - 0.01388888888888889 * b19 - 0.002083333333333333 * b2 + 0.02083333333333333 * b20 - 0.01388888888888889 * b21 + 0.003472222222222222 * b22 - 0.001736111111111111 * b24 + 0.006944444444444444 * b25 - 0.01041666666666667 * b26 + 0.006944444444444444 * b27 - 0.001736111111111111 * b28 + 0.001388888888888889 * b3 + 0.0003472222222222222 * b30 - 0.001388888888888889 * b31 + 0.002083333333333333 * b32 - 0.001388888888888889 * b33 + 0.0003472222222222222 * b34 - 0.0003472222222222222 * b4 + 0.001736111111111111 * b6 - 0.006944444444444444 * b7 + 0.01041666666666667 * b8 - 0.006944444444444444 * b9;
            QK_B_QKT_buffer[lind_qkbqkt + 35] = 0.00006944444444444444 * b0 - 0.0003472222222222222 * b1 - 0.001736111111111111 * b10 + 0.0003472222222222222 * b11 + 0.0006944444444444444 * b12 - 0.003472222222222222 * b13 + 0.006944444444444444 * b14 - 0.006944444444444444 * b15 + 0.003472222222222222 * b16 - 0.0006944444444444444 * b17 - 0.0006944444444444444 * b18 + 0.003472222222222222 * b19 + 0.0006944444444444444 * b2 - 0.006944444444444444 * b20 + 0.006944444444444444 * b21 - 0.003472222222222222 * b22 + 0.0006944444444444444 * b23 + 0.0003472222222222222 * b24 - 0.001736111111111111 * b25 + 0.003472222222222222 * b26 - 0.003472222222222222 * b27 + 0.001736111111111111 * b28 - 0.0003472222222222222 * b29 - 0.0006944444444444444 * b3 - 0.00006944444444444444 * b30 + 0.0003472222222222222 * b31 - 0.0006944444444444444 * b32 + 0.0006944444444444444 * b33 - 0.0003472222222222222 * b34 + 0.00006944444444444444 * b35 + 0.0003472222222222222 * b4 - 0.00006944444444444444 * b5 - 0.0003472222222222222 * b6 + 0.001736111111111111 * b7 - 0.003472222222222222 * b8 + 0.003472222222222222 * b9;
        }
    }
}

void Dic::analysis(std::ofstream &of, std::size_t currImg) {
    //    of << "Inside analysis for current image " << currImg << "\n";
    int spacing = params.subsetSpacing;
    //    of << "Total regions are " << roi.region.size() << "\n";
    for (std::size_t num_region = 0; num_region < roi.region.size(); num_region++) {
        //        of << "Updating cirroi for region " << num_region << "\n";
        roi.update_cirroi(num_region);

        //        of << "Initialize queue\n";
        heap queue;
        //        of << "Creating file for separate qorder list\n";
        //        std::ofstream qf(QString("./qorder%1.txt").arg(currImg).toStdString());

        // Add seed to queue
        // [x y u v du/dx du/dy dv/dx dv/dy corrcoef]
        std::vector<double> paramvector_seed(9, 0);

        // seed is to be used here
        paramvector_seed[0] = seed_info[currImg][0];
        paramvector_seed[1] = seed_info[currImg][1];
        paramvector_seed[2] = seed_info[currImg][2];
        paramvector_seed[3] = seed_info[currImg][3];
        paramvector_seed[4] = seed_info[currImg][4];
        paramvector_seed[5] = seed_info[currImg][5];
        paramvector_seed[6] = seed_info[currImg][6];
        paramvector_seed[7] = seed_info[currImg][7];
        paramvector_seed[8] = seed_info[currImg][8];
        queue.push(paramvector_seed);

        //        of << "Seed added to queue with values : ";
        //        for (const auto &e : paramvector_seed)
        //            of << e << " ";
        //        of << "\n";

        //        of << "Inactivate seed point and mark it as calculated and valid\n";
        int x_seed_reduced = static_cast<int>(paramvector_seed[0]) / (spacing + 1); // x_seed and y_seed are guaranteed divisible by (spacing+1)
        int y_seed_reduced = static_cast<int>(paramvector_seed[1]) / (spacing + 1);
        plot_calcpoints.value[y_seed_reduced + x_seed_reduced * plot_calcpoints.height] = true;
        plot_validpoints[currImg].value[y_seed_reduced + x_seed_reduced * plot_validpoints[currImg].height] = true;

        //        of << "Starting while loop for queue\n";
        // Enter While Loop - Exit when queue is empty
        while (!queue.empty()) {
            // 1) Load point with lowest correlation coefficient from queue
            // 2) Delete point from queue
            // 3) Add data to plots
            // 4) Analyze four surrounding points and sort

            // Step 1: load
            std::vector<double> paramvector_init = queue.top();

            //of <<  "Queue pop at : ";
            //            for (const auto &e : paramvector_init) {
            //of <<  e << " ";
            //                qf << e << " ";
            //            }
            //of <<  "\n";

            // Step 2: delete
            queue.pop();
            of << paramvector_init[0] << ", " << paramvector_init[1] << "\n";

            // Step 3: add data to plots
            int x_init_reduced = static_cast<int>(paramvector_init[0]) / (spacing + 1);
            int y_init_reduced = static_cast<int>(paramvector_init[1]) / (spacing + 1);
            plot_u[currImg].value[y_init_reduced + x_init_reduced * plot_u[currImg].height] = paramvector_init[2];
            plot_v[currImg].value[y_init_reduced + x_init_reduced * plot_v[currImg].height] = paramvector_init[3];
            plot_corrcoef[currImg].value[y_init_reduced + x_init_reduced * plot_corrcoef[currImg].height] = paramvector_init[8];

            //            of << "Analysing surroinding points of (" << paramvector_init[0] << ", " << paramvector_init[1] << ")\n";
            // Step 4: analyze four surrounding points - must increment by spacing parameter
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]), static_cast<int>(paramvector_init[1]) - (spacing + 1), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]) + (spacing + 1), static_cast<int>(paramvector_init[1]), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]), static_cast<int>(paramvector_init[1]) + (spacing + 1), paramvector_init, num_region);
            analyzepoint(of, currImg, queue, static_cast<int>(paramvector_init[0]) - (spacing + 1), static_cast<int>(paramvector_init[1]), paramvector_init, num_region);
        }
    }
}

void Dic::analyzepoint(std::ofstream &of, std::size_t currImg, heap &queue, const int &x, const int &y, const std::vector<double> &paramvector_init, const int &num_region) {
    int spacing = params.subsetSpacing;

    // These are read only, so they are thread safe
    static double cutoff_corrcoef = 2.0;     // Heuristic, but 2.0 is pretty high. Range is [0,4]. Different images can have different corrcoef cutoffs which work well, so set this to a low value
    static double cutoff_disp = spacing + 1; // Heuristic, this prevents large displacement jumps (most likely incorrect data) form being added

    // Reduce coordinates first
    int x_reduced = x / (spacing + 1);
    int y_reduced = y / (spacing + 1);
    //of <<  "Analysing point (" << x << ", " << y << "), reduced version (" << x_reduced << ", " << y_reduced << ")\n";

    // Make sure point is within region bounds first
    if (x >= roi.region[num_region].leftbound &&
        x <= roi.region[num_region].rightbound &&
        y >= roi.region[num_region].upperbound &&
        y <= roi.region[num_region].lowerbound &&
        !plot_calcpoints.value[y_reduced + x_reduced * plot_calcpoints.height] &&
        roi.withinregion(x, y, num_region)) {
        //of <<  "Point was within region bounds. Ok to proceed\n";

        // Initialize paramvector
        std::vector<double> paramvector(9, 0); // [x y u v du/dx du/dy dv/dx dv/dy corrcoef]

        //of <<  "Calling calpoint for this point\n";
        // Calculate paramvector for a point
        bool outstate = calcpoint(of, currImg, paramvector, x, y, paramvector_init, num_region);

        // Make sure parameters are correct before adding them to queue
        if (outstate &&
            paramvector[8] < cutoff_corrcoef &&
            fabs(paramvector_init[2] - paramvector[2]) < cutoff_disp &&
            fabs(paramvector_init[3] - paramvector[3]) < cutoff_disp) {
            // Insert paramvector based on correlation coefficient
            //            of << "Calcpoint was success!\n";
            queue.push(paramvector);

            // Valid Point
            plot_validpoints[currImg].value[y_reduced + x_reduced * plot_validpoints[currImg].height] = true;
        } else {
            //            of << "Calcpoint failed.\n";
        }
        // Calculated point
        plot_calcpoints.value[y_reduced + x_reduced * plot_calcpoints.height] = true;
    } else {
        //        of << "Point not in region. Wrong point.\n";
    }
}

bool Dic::calcpoint(std::ofstream &of, std::size_t currImg, std::vector<double> &paramvector, const int &x, const int &y, const std::vector<double> &paramvector_init, const int &num_region) {
    // Get cirroi -> Find initial guess -> Refine results with IC-GN -> Return true or false and store output
    // Step 1: Get cirroi
    //subsettrunc = false
    //of <<  "Called get cirroi for (" << x << ", " << y << ") point\n";
    roi.get_cirroi(x, y, num_region, false);

    // Step 2: Get initial guess - Use displacement and displacement gradients to get initial guess
    std::vector<double> defvector_init(6, 0); // [u v du/dx du/dy dv/dx dv/dy]
    // u_init = u+du/dx*x_delta+du/dy*y_delta;
    // v_init = v+dv/dx*x_delta+dv/dy*y_delta;
    defvector_init[0] = paramvector_init[2] + paramvector_init[4] * (x - paramvector_init[0]) + paramvector_init[5] * (y - paramvector_init[1]);
    defvector_init[1] = paramvector_init[3] + paramvector_init[6] * (x - paramvector_init[0]) + paramvector_init[7] * (y - paramvector_init[1]);
    defvector_init[2] = paramvector_init[4];
    defvector_init[3] = paramvector_init[5];
    defvector_init[4] = paramvector_init[6];
    defvector_init[5] = paramvector_init[7];

    // Step 3: Get refined results with IC-GN
    std::vector<double> defvector(6, 0); // [u v du/dx du/dy dv/dx dv/dy]
    double corrcoef;
    //of <<  "Getting corr using iterative search\n";
    bool outstate_iterative = iterativesearch(of, currImg, defvector, corrcoef, defvector_init);

    if (outstate_iterative) {
        // Step 4: Store output and return true
        paramvector[0] = x;
        paramvector[1] = y;
        paramvector[2] = defvector[0];
        paramvector[3] = defvector[1];
        paramvector[4] = defvector[2];
        paramvector[5] = defvector[3];
        paramvector[6] = defvector[4];
        paramvector[7] = defvector[5];
        paramvector[8] = corrcoef;
        //of <<  "Iterative search pass and calcpoint success\n";
        //of <<  "Corr was " << corrcoef << "\n";
        return true;
    }
    //of <<  "Iterative search failed!\n";
    return false;
}

bool Dic::iterativesearch(std::ofstream &of, std::size_t currImg, std::vector<double> &defvector, double &corrcoef, const std::vector<double> &defvector_init) {

    // Calculate fm
    double fm = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_ref = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                fm += rimg.gs.value[lind_ref];
            }
        }
    }
    fm = fm / (double)roi.cirroi.region.totalpoints;
    //of << "fm is " << fm << "\n";

    // Calculate deltaf_inf
    double deltaf_inv = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_ref = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                deltaf_inv += pow(rimg.gs.value[lind_ref] - fm, 2);
            }
        }
    }
    deltaf_inv = sqrt(deltaf_inv);
    //of <<  "delta inf " << deltaf_inv << "\n";

    // check to make sure deltaf_inv (strictly positive) isn't close to zero; if it is, iterative search fails
    if (deltaf_inv > LAMBDA) {
        // Finish deltaf_inv
        deltaf_inv = 1.0 / deltaf_inv;

        // Precompute "Steepest descent images"
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Find new coordinates
                    double dx = (double)(i - roi.cirroi.radius);
                    double dy = (double)(k - roi.cirroi.y);

                    int y_tilda_floor = k;
                    int x_tilda_floor = i + (roi.cirroi.x - roi.cirroi.radius);

                    // Calculate lind_f for gradient and lind_df for the first order "steepest descent images"
                    int lind_f = y_tilda_floor + x_tilda_floor * rimg.gs.height;
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);

                    // First order
                    df_dp_buffer[lind_df] = df_dx_buffer[lind_f];          // u
                    df_dp_buffer[lind_df + 1] = df_dy_buffer[lind_f];      // v
                    df_dp_buffer[lind_df + 2] = df_dx_buffer[lind_f] * dx; // dudx
                    df_dp_buffer[lind_df + 3] = df_dx_buffer[lind_f] * dy; // dudy
                    df_dp_buffer[lind_df + 4] = df_dy_buffer[lind_f] * dx; // dvdx
                    df_dp_buffer[lind_df + 5] = df_dy_buffer[lind_f] * dy; // dvdy
                }
            }
        }

        // Precompute GN hessian
        // Initialize to zero first
        std::fill(hessian_gn_buffer.begin(), hessian_gn_buffer.end(), 0.0);
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Parameters
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);

                    // Hessian - only calculate lower half since hessian is symmetric
                    hessian_gn_buffer[0] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df];
                    hessian_gn_buffer[1] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 1];
                    hessian_gn_buffer[2] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[3] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[4] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[5] += df_dp_buffer[lind_df] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[7] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 1];
                    hessian_gn_buffer[8] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[9] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[10] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[11] += df_dp_buffer[lind_df + 1] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[14] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 2];
                    hessian_gn_buffer[15] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[16] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[17] += df_dp_buffer[lind_df + 2] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[21] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 3];
                    hessian_gn_buffer[22] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[23] += df_dp_buffer[lind_df + 3] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[28] += df_dp_buffer[lind_df + 4] * df_dp_buffer[lind_df + 4];
                    hessian_gn_buffer[29] += df_dp_buffer[lind_df + 4] * df_dp_buffer[lind_df + 5];

                    hessian_gn_buffer[35] += df_dp_buffer[lind_df + 5] * df_dp_buffer[lind_df + 5];
                }
            }
        }

        // Multiply components of hessian by 2/deltaf^2
        for (int i = 0; i < 6; i++) {
            for (int j = i; j < 6; j++) {
                hessian_gn_buffer[j + i * 6] *= 2 * pow(deltaf_inv, 2);
            }
        }

        // Fill other half of hessian
        hessian_gn_buffer[6] = hessian_gn_buffer[1];

        hessian_gn_buffer[12] = hessian_gn_buffer[2];
        hessian_gn_buffer[13] = hessian_gn_buffer[8];

        hessian_gn_buffer[18] = hessian_gn_buffer[3];
        hessian_gn_buffer[19] = hessian_gn_buffer[9];
        hessian_gn_buffer[20] = hessian_gn_buffer[15];

        hessian_gn_buffer[24] = hessian_gn_buffer[4];
        hessian_gn_buffer[25] = hessian_gn_buffer[10];
        hessian_gn_buffer[26] = hessian_gn_buffer[16];
        hessian_gn_buffer[27] = hessian_gn_buffer[22];

        hessian_gn_buffer[30] = hessian_gn_buffer[5];
        hessian_gn_buffer[31] = hessian_gn_buffer[11];
        hessian_gn_buffer[32] = hessian_gn_buffer[17];
        hessian_gn_buffer[33] = hessian_gn_buffer[23];
        hessian_gn_buffer[34] = hessian_gn_buffer[29];

        // Solve for new parameters via cholesky decomp (from Golub and Van Loan)
        // Lower triangle of Hessian overwritten with parameters used in Cholesky decomp
        // If one of the diagonals is close to zero or negative, then the
        // hessian is not positive definite
        bool positivedef = true;
        Utils::cholesky(hessian_gn_buffer, positivedef, 6);

        if (positivedef) {
            // Start iterations - For first iteration use defvector_init
            double diffnorm;
            bool outstate_newton = newton(of, currImg, defvector, corrcoef, diffnorm, defvector_init, fm, deltaf_inv);

            // Initialize counter
            int counter = 1;
            while (outstate_newton && diffnorm >= params.cutoff_diffnorm && counter <= params.cutoff_iteration) {
                // For rest of iterations use defvector from previous iterations
                outstate_newton = newton(of, currImg, defvector, corrcoef, diffnorm, defvector, fm, deltaf_inv);
                ++counter;
            }

            if (outstate_newton) {
                return true;
            }
        }
    }
    // Some parameters are invalid - either deltag_inv was zero or the hessian wasn't positive definite
    return false;
}

bool Dic::newton(std::ofstream &of, std::size_t currImg, std::vector<double> &defvector, double &corrcoef, double &diffnorm, const std::vector<double> &defvector_init, const double &fm, const double &deltaf_inv) {
    // Will only overwrite queue_new if parameters are valid
    // Interpolate g subset - do this here instead of interp_qbs because QK_B_QKT has been precomputed
    double gm = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                // Find new coordinates
                double dx = (double)(i - roi.cirroi.radius);
                double dy = (double)(k - roi.cirroi.y);

                double y_tilda = (double)k + defvector_init[1] + defvector_init[4] * dx + defvector_init[5] * dy;
                double x_tilda = (double)(i + (roi.cirroi.x - roi.cirroi.radius)) + defvector_init[0] + defvector_init[2] * dx + defvector_init[3] * dy;

                int x_tilda_floor = (int)floor(x_tilda);
                int y_tilda_floor = (int)floor(y_tilda);

                int lind_g = (int)dy + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;

                // Get bounds of the desired b-spline coefficients used for interpolation
                int top = y_tilda_floor + cimgs[currImg].border_bcoef - 2;
                int left = x_tilda_floor + cimgs[currImg].border_bcoef - 2;
                int bottom = y_tilda_floor + cimgs[currImg].border_bcoef + 3;
                int right = x_tilda_floor + cimgs[currImg].border_bcoef + 3;

                if (top >= 0 &&
                    left >= 0 &&
                    bottom < cimgs[currImg].bcoef.height &&
                    right < cimgs[currImg].bcoef.width) {
                    double x_tilda_delta = x_tilda - (double)x_tilda_floor;
                    double y_tilda_delta = y_tilda - (double)y_tilda_floor;

                    // Form x_vec
                    x_vec_buffer[1] = x_tilda_delta;
                    x_vec_buffer[2] = x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[3] = x_tilda_delta * x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[4] = x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta;
                    x_vec_buffer[5] = x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta * x_tilda_delta;

                    // Form y_vec
                    y_vec_buffer[1] = y_tilda_delta;
                    y_vec_buffer[2] = y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[3] = y_tilda_delta * y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[4] = y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta;
                    y_vec_buffer[5] = y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta * y_tilda_delta;

                    // Calculate lind_qkbqkt for QK_B_QKT
                    int lind_qkbqkt = (top * 36) + (left * 36 * (cimgs[currImg].bcoef.height - 5));

                    // Get QK_B_QKT coefficients
                    double QK_B_QKT_0 = QK_B_QKT_buffer[lind_qkbqkt];
                    double QK_B_QKT_1 = QK_B_QKT_buffer[lind_qkbqkt + 1];
                    double QK_B_QKT_2 = QK_B_QKT_buffer[lind_qkbqkt + 2];
                    double QK_B_QKT_3 = QK_B_QKT_buffer[lind_qkbqkt + 3];
                    double QK_B_QKT_4 = QK_B_QKT_buffer[lind_qkbqkt + 4];
                    double QK_B_QKT_5 = QK_B_QKT_buffer[lind_qkbqkt + 5];
                    double QK_B_QKT_6 = QK_B_QKT_buffer[lind_qkbqkt + 6];
                    double QK_B_QKT_7 = QK_B_QKT_buffer[lind_qkbqkt + 7];
                    double QK_B_QKT_8 = QK_B_QKT_buffer[lind_qkbqkt + 8];
                    double QK_B_QKT_9 = QK_B_QKT_buffer[lind_qkbqkt + 9];
                    double QK_B_QKT_10 = QK_B_QKT_buffer[lind_qkbqkt + 10];
                    double QK_B_QKT_11 = QK_B_QKT_buffer[lind_qkbqkt + 11];
                    double QK_B_QKT_12 = QK_B_QKT_buffer[lind_qkbqkt + 12];
                    double QK_B_QKT_13 = QK_B_QKT_buffer[lind_qkbqkt + 13];
                    double QK_B_QKT_14 = QK_B_QKT_buffer[lind_qkbqkt + 14];
                    double QK_B_QKT_15 = QK_B_QKT_buffer[lind_qkbqkt + 15];
                    double QK_B_QKT_16 = QK_B_QKT_buffer[lind_qkbqkt + 16];
                    double QK_B_QKT_17 = QK_B_QKT_buffer[lind_qkbqkt + 17];
                    double QK_B_QKT_18 = QK_B_QKT_buffer[lind_qkbqkt + 18];
                    double QK_B_QKT_19 = QK_B_QKT_buffer[lind_qkbqkt + 19];
                    double QK_B_QKT_20 = QK_B_QKT_buffer[lind_qkbqkt + 20];
                    double QK_B_QKT_21 = QK_B_QKT_buffer[lind_qkbqkt + 21];
                    double QK_B_QKT_22 = QK_B_QKT_buffer[lind_qkbqkt + 22];
                    double QK_B_QKT_23 = QK_B_QKT_buffer[lind_qkbqkt + 23];
                    double QK_B_QKT_24 = QK_B_QKT_buffer[lind_qkbqkt + 24];
                    double QK_B_QKT_25 = QK_B_QKT_buffer[lind_qkbqkt + 25];
                    double QK_B_QKT_26 = QK_B_QKT_buffer[lind_qkbqkt + 26];
                    double QK_B_QKT_27 = QK_B_QKT_buffer[lind_qkbqkt + 27];
                    double QK_B_QKT_28 = QK_B_QKT_buffer[lind_qkbqkt + 28];
                    double QK_B_QKT_29 = QK_B_QKT_buffer[lind_qkbqkt + 29];
                    double QK_B_QKT_30 = QK_B_QKT_buffer[lind_qkbqkt + 30];
                    double QK_B_QKT_31 = QK_B_QKT_buffer[lind_qkbqkt + 31];
                    double QK_B_QKT_32 = QK_B_QKT_buffer[lind_qkbqkt + 32];
                    double QK_B_QKT_33 = QK_B_QKT_buffer[lind_qkbqkt + 33];
                    double QK_B_QKT_34 = QK_B_QKT_buffer[lind_qkbqkt + 34];
                    double QK_B_QKT_35 = QK_B_QKT_buffer[lind_qkbqkt + 35];

                    // Calculate g - main computational bottleneck of the inverse compositional method with biquintic b-splines
                    g_buffer[lind_g] = (QK_B_QKT_0 + x_vec_buffer[1] * QK_B_QKT_6 + x_vec_buffer[2] * QK_B_QKT_12 + x_vec_buffer[3] * QK_B_QKT_18 + x_vec_buffer[4] * QK_B_QKT_24 + x_vec_buffer[5] * QK_B_QKT_30) +
                                       (QK_B_QKT_1 + x_vec_buffer[1] * QK_B_QKT_7 + x_vec_buffer[2] * QK_B_QKT_13 + x_vec_buffer[3] * QK_B_QKT_19 + x_vec_buffer[4] * QK_B_QKT_25 + x_vec_buffer[5] * QK_B_QKT_31) * y_vec_buffer[1] +
                                       (QK_B_QKT_2 + x_vec_buffer[1] * QK_B_QKT_8 + x_vec_buffer[2] * QK_B_QKT_14 + x_vec_buffer[3] * QK_B_QKT_20 + x_vec_buffer[4] * QK_B_QKT_26 + x_vec_buffer[5] * QK_B_QKT_32) * y_vec_buffer[2] +
                                       (QK_B_QKT_3 + x_vec_buffer[1] * QK_B_QKT_9 + x_vec_buffer[2] * QK_B_QKT_15 + x_vec_buffer[3] * QK_B_QKT_21 + x_vec_buffer[4] * QK_B_QKT_27 + x_vec_buffer[5] * QK_B_QKT_33) * y_vec_buffer[3] +
                                       (QK_B_QKT_4 + x_vec_buffer[1] * QK_B_QKT_10 + x_vec_buffer[2] * QK_B_QKT_16 + x_vec_buffer[3] * QK_B_QKT_22 + x_vec_buffer[4] * QK_B_QKT_28 + x_vec_buffer[5] * QK_B_QKT_34) * y_vec_buffer[4] +
                                       (QK_B_QKT_5 + x_vec_buffer[1] * QK_B_QKT_11 + x_vec_buffer[2] * QK_B_QKT_17 + x_vec_buffer[3] * QK_B_QKT_23 + x_vec_buffer[4] * QK_B_QKT_29 + x_vec_buffer[5] * QK_B_QKT_35) * y_vec_buffer[5];

                    // Add components to calculate the mean
                    gm += g_buffer[lind_g];
                } else {
                    // If this condition is satisfied then we are
                    // interpolating a point beyond the bounds of the
                    // original image, so just set the values to zero
                    g_buffer[lind_g] = 0.0;

                    // Don't add anything to averages
                    continue;
                }
            }
        }
    }
    // Divide by totalpoints to get real average
    gm /= static_cast<double>(roi.cirroi.region.totalpoints);

    // Calculate deltag_inv
    double deltag_inv = 0.0;
    for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
        for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
            for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                int lind_g = (k - roi.cirroi.y) + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;
                deltag_inv = deltag_inv + pow(g_buffer[lind_g] - gm, 2);
            }
        }
    }
    deltag_inv = sqrt(deltag_inv); // This is deltag; will take inverse after ensuring it is not close to zero

    // check to make sure deltag_inv (strictly positive) isn't close to zero; if it is, exit newton raphson
    if (deltag_inv > LAMBDA) {
        // Finish deltag_inv
        deltag_inv = 1.0 / deltag_inv;

        // Calculate gradient
        // Initialize to zero first
        std::fill(gradient_buffer.begin(), gradient_buffer.end(), 0.0);
        corrcoef = 0.0;
        for (int i = 0; i < roi.cirroi.region.noderange.height; i++) {
            for (int j = 0; j < roi.cirroi.region.noderange.value[i]; j += 2) {
                for (int k = roi.cirroi.region.nodelist.value[i + j * roi.cirroi.region.nodelist.height]; k <= roi.cirroi.region.nodelist.value[i + (j + 1) * roi.cirroi.region.nodelist.height]; k++) {
                    // Parameters
                    int lind_f = k + (i + (roi.cirroi.x - roi.cirroi.radius)) * rimg.gs.height;
                    int lind_df = ((k - roi.cirroi.y) + roi.cirroi.radius) * 6 + i * (roi.cirroi.region.nodelist.height * 6);
                    int lind_g = (k - roi.cirroi.y) + roi.cirroi.radius + i * roi.cirroi.region.nodelist.height;

                    // Gradient Parameters
                    double normalized_diff = (rimg.gs.value[lind_f] - fm) * deltaf_inv - (g_buffer[lind_g] - gm) * deltag_inv;

                    // Gradient
                    gradient_buffer[0] += normalized_diff * df_dp_buffer[lind_df];
                    gradient_buffer[1] += normalized_diff * df_dp_buffer[lind_df + 1];
                    gradient_buffer[2] += normalized_diff * df_dp_buffer[lind_df + 2];
                    gradient_buffer[3] += normalized_diff * df_dp_buffer[lind_df + 3];
                    gradient_buffer[4] += normalized_diff * df_dp_buffer[lind_df + 4];
                    gradient_buffer[5] += normalized_diff * df_dp_buffer[lind_df + 5];

                    // Correlation coefficient
                    corrcoef += pow(normalized_diff, 2);
                }
            }
        }

        // Update gradient; multiply by the inverses
        for (int i = 0; i < 6; i++) {
            gradient_buffer[i] *= 2 * deltaf_inv;
        }

        // Find new change in deformation parameters
        // Ax = b
        // GG'x = b, where G is lower triangular
        // Gy = b -> G'x = y
        // Step 1: solve for y with forward substitution; y is stored in gradient_buffer
        Utils::forwardsub(gradient_buffer, hessian_gn_buffer, 6);

        // Step 2: solve for x with back substitution
        Utils::backwardsub(gradient_buffer, hessian_gn_buffer, 6);

        // Make gradient_buffer negative
        for (int i = 0; i < 6; i++) {
            gradient_buffer[i] = -gradient_buffer[i];
        }

        // At this point the change in deformation parameters is stored in gradient_buffer
        // Calculate difference norm - this is stored in gradient_buffer at this point
        diffnorm = 0.0;
        for (int i = 0; i < 6; i++) {
            diffnorm += gradient_buffer[i] * gradient_buffer[i];
        }
        diffnorm = sqrt(diffnorm);

        // Update parameters using inverse composition
        // Transfer parameters because defvector_init is an alias of defvector after the first iteration
        double defvector_init_u = defvector_init[0];
        double defvector_init_v = defvector_init[1];
        double defvector_init_dudx = defvector_init[2];
        double defvector_init_dudy = defvector_init[3];
        double defvector_init_dvdx = defvector_init[4];
        double defvector_init_dvdy = defvector_init[5];
        defvector[0] = defvector_init_u - ((defvector_init_dudx + 1) * (gradient_buffer[0] + gradient_buffer[0] * gradient_buffer[5] - gradient_buffer[1] * gradient_buffer[3])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (defvector_init_dudy * (gradient_buffer[1] - gradient_buffer[0] * gradient_buffer[4] + gradient_buffer[1] * gradient_buffer[2])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1); // u
        defvector[1] = defvector_init_v - ((defvector_init_dvdy + 1) * (gradient_buffer[1] - gradient_buffer[0] * gradient_buffer[4] + gradient_buffer[1] * gradient_buffer[2])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (defvector_init_dvdx * (gradient_buffer[0] + gradient_buffer[0] * gradient_buffer[5] - gradient_buffer[1] * gradient_buffer[3])) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1); // v
        defvector[2] = ((gradient_buffer[5] + 1) * (defvector_init_dudx + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[4] * defvector_init_dudy) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - 1;                                                                                                                                                                                      // du/dx
        defvector[3] = (defvector_init_dudy * (gradient_buffer[2] + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[3] * (defvector_init_dudx + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1);                                                                                                                                                                                          // du/dy
        defvector[4] = (defvector_init_dvdx * (gradient_buffer[5] + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[4] * (defvector_init_dvdy + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1);                                                                                                                                                                                          // dv/dx
        defvector[5] = ((gradient_buffer[2] + 1) * (defvector_init_dvdy + 1)) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - (gradient_buffer[3] * defvector_init_dvdx) / (gradient_buffer[2] + gradient_buffer[5] + gradient_buffer[2] * gradient_buffer[5] - gradient_buffer[3] * gradient_buffer[4] + 1) - 1;                                                                                                                                                                                      // dv/dy

        // Return successful
        return true;
    }
    // Deltag was close to zero - return failed
    return false;
}

void Dic::matchSeed(std::size_t currentIndex) {
    double maxCorrelation = 0.0, correlation;
    std::pair<int, int> match, candidate;
    std::vector<double> serialSeed =
        serializeSubset(rimg, params.seedPoint);
    for (int i = 0; i < cimgs[currentIndex].gs.height; i++) {
        for (int j = 0; j < cimgs[currentIndex].gs.width; j++) {
            candidate = std::make_pair(i, j);
            correlation = Utils::ncc(
                serialSeed, serializeSubset(cimgs[currentIndex], candidate));
            if (correlation > maxCorrelation) {
                match = candidate;
                maxCorrelation = correlation;
            }
        }
    }
    /*qDebug() << QString("for %1 th current image, found match at {%2, %3} with "
                        "correlation = %4")
                    .arg(currentIndex)
                    .arg(match.first)
                    .arg(match.second)
                    .arg(maxCorrelation);*/
}

std::vector<double> Dic::serializeSubset(class_img &image,
                                         std::pair<int, int> center) {
    unsigned long xMin = 0;
    unsigned long xMax = static_cast<unsigned long>(image.gs.width) - 1;
    unsigned long yMin = 0;
    unsigned long yMax = static_cast<unsigned long>(image.gs.height) - 1;
    unsigned long side = static_cast<unsigned long>(params.subsetSize);
    unsigned long xStart = static_cast<unsigned long>(center.first) - side / 2;
    unsigned long yStart = static_cast<unsigned long>(center.second) - side / 2;
    unsigned long x;
    unsigned long y;
    std::vector<double> res(static_cast<size_t>(side * side), 0.0);

    if (xStart < xMin or yStart < yMin or xStart + side - 1 > xMax or
        yStart + side - 1 > yMax) {
        std::vector<double> empty;
        return empty;
    }
    x = xStart;
    /*for (size_t i = 0; i < side; i++, x++) {
        y = yStart;
        for (size_t j = 0; j < side; j++, y++) {
            res[i * side + j] = static_cast<double>(image.getValue(static_cast<int>(x), static_cast<int>(y)));
        }
    }*/
    return res;
}
